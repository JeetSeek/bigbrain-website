[{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/App.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/__mocks__/supabaseClient.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":9,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":10,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":10,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":11,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":12,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":13,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":13,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":14,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":15,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":16,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":17,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":17,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":18,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":19,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":20,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":21,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":24,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":24,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":25,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":25,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":26,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":27,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":28,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":30,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":57},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":34,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":35,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":35,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":36,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":37,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":37,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":38,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":41,"column":8,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":12}],"suppressedMessages":[],"errorCount":25,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Mock Supabase Client for Testing\n * \n * This mock replaces the actual Supabase client in test environments\n * to avoid issues with import.meta.env and to provide consistent test behavior\n */\n\nexport const supabase = {\n  from: jest.fn().mockReturnValue({\n    select: jest.fn().mockReturnThis(),\n    insert: jest.fn().mockReturnThis(),\n    update: jest.fn().mockReturnThis(),\n    delete: jest.fn().mockReturnThis(),\n    eq: jest.fn().mockReturnThis(),\n    in: jest.fn().mockReturnThis(),\n    single: jest.fn().mockReturnValue({ data: null, error: null }),\n    match: jest.fn().mockReturnThis(),\n    order: jest.fn().mockReturnThis(),\n    limit: jest.fn().mockReturnThis(),\n    range: jest.fn().mockReturnThis(),\n    then: jest.fn().mockImplementation(callback => Promise.resolve(callback({ data: [], error: null }))),\n  }),\n  auth: {\n    getUser: jest.fn().mockResolvedValue({ data: { user: null }, error: null }),\n    signIn: jest.fn().mockResolvedValue({ data: {}, error: null }),\n    signOut: jest.fn().mockResolvedValue({ error: null }),\n    signUp: jest.fn().mockResolvedValue({ data: {}, error: null }),\n    onAuthStateChange: jest.fn().mockImplementation((callback) => {\n      callback('SIGNED_IN', { user: { id: 'test-user-id' } });\n      return { data: { subscription: { unsubscribe: jest.fn() } } };\n    }),\n  },\n  storage: {\n    from: jest.fn().mockReturnValue({\n      upload: jest.fn().mockResolvedValue({ data: {}, error: null }),\n      getPublicUrl: jest.fn().mockReturnValue({ data: { publicUrl: 'https://example.com/test.jpg' } }),\n      list: jest.fn().mockResolvedValue({ data: [], error: null }),\n      remove: jest.fn().mockResolvedValue({ error: null }),\n    }),\n  },\n  rpc: jest.fn().mockResolvedValue({ data: [], error: null }),\n};\n\nexport default supabase;\n","usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/__tests__/components/AdminDashboard.test.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/__tests__/components/ChatDock.test.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/AdminDashboard.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/ChatDock.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/ErrorBoundary.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/FeedbackForm.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/MainContent.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/ManualFinder.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/ManualFinderStandalone.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/Navbar.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/PaymentHistory.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/ServiceStatus.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/SettingsPanel.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/Sidebar.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/SupportTickets.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/fixes/ErrorBoundary.enhanced.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/fixes/FixedManualFinderStandalone.combined.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/fixes/FixedManualFinderStandalone.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/fixes/FixedManualFinderStandalone2.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/components/fixes/FixedManualFinderStandalone3.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/contexts/AuthContext.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/deepseek.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":24,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":24,"endColumn":35}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Utility to call DeepSeek APIs with fallback logic\n// Tries up to 5 endpoints in order until one succeeds\n\nconst deepseekEndpoints = [\n  import.meta.env.VITE_DEEPSEEK_API_URL_1,\n  import.meta.env.VITE_DEEPSEEK_API_URL_2,\n  import.meta.env.VITE_DEEPSEEK_API_URL_3,\n  import.meta.env.VITE_DEEPSEEK_API_URL_4,\n  import.meta.env.VITE_DEEPSEEK_API_URL_5,\n];\n\n/**\n * Calls each DeepSeek API endpoint in order until one succeeds.\n * @param {string} path - The API path (e.g., '/chat')\n * @param {object} options - Fetch options (method, headers, body, etc.)\n * @returns {Promise<Response>} The successful fetch response\n * @throws If all endpoints fail\n */\nexport async function callDeepSeekWithFallback(path, options) {\n  let lastError;\n  for (const baseUrl of deepseekEndpoints) {\n    if (!baseUrl) continue;\n    try {\n      const response = await fetch(baseUrl + path, options);\n      if (response.ok) return response;\n      lastError = new Error(`Endpoint ${baseUrl} responded with status ${response.status}`);\n    } catch (err) {\n      lastError = err;\n    }\n  }\n  throw lastError || new Error('No DeepSeek endpoints available');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/main.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/pages/Chat.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/pages/Login.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/pages/Register.jsx","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because no matching configuration was supplied.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/supabaseClient.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/utils/adminApiService.js","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":46,"fix":{"range":[231,231],"text":"\n"}},{"ruleId":"no-unused-vars","severity":1,"message":"'API' is defined but never used.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":13,"suggestions":[{"messageId":"removeVar","data":{"varName":"API"},"fix":{"range":[241,245],"text":""},"desc":"Remove unused variable 'API'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'API' is defined but never used.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":13},{"ruleId":"no-unused-vars","severity":1,"message":"'DEMO' is defined but never used.","line":8,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":40,"suggestions":[{"messageId":"removeVar","data":{"varName":"DEMO"},"fix":{"range":[265,271],"text":""},"desc":"Remove unused variable 'DEMO'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DEMO' is defined but never used.","line":8,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":26,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":26},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":30,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":30,"endColumn":17,"suggestions":[{"fix":{"range":[887,940],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":78,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":78,"endColumn":20,"suggestions":[{"fix":{"range":[2489,2541],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":156,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":156,"endColumn":18,"suggestions":[{"fix":{"range":[4668,4714],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":227,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":227,"endColumn":20,"suggestions":[{"fix":{"range":[6321,6377],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'cacheData' is not defined.","line":298,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":298,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":302,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":302,"endColumn":18,"suggestions":[{"fix":{"range":[9041,9097],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":373,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":373,"endColumn":18,"suggestions":[{"fix":{"range":[10905,10950],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":409,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":409,"endColumn":18,"suggestions":[{"fix":{"range":[11789,11845],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":450,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":450,"endColumn":18,"suggestions":[{"fix":{"range":[12879,12935],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/**\n * Admin API Service\n * Provides functions for interacting with admin-specific API endpoints\n * Handles authentication, error handling, and data formatting for admin operations\n */\n\nimport { supabase } from '../supabaseClient';\nimport { API, CACHE, STORAGE_KEYS, DEMO } from './constants';\nimport { setCachedData, getCachedData } from './cacheUtils';\n\nconst ADMIN_CACHE_KEYS = {\n  USERS: 'admin_users',\n  ANALYTICS: 'admin_analytics',\n  USAGE_STATS: 'admin_usage_stats',\n  PAYMENT_SUMMARY: 'admin_payment_summary',\n};\n\n/**\n * Check if demo mode is active\n * @returns {boolean} - True if demo mode is active\n */\nfunction isDemoMode() {\n  try {\n    // Safe check for localStorage availability\n    if (typeof window !== 'undefined' && window.localStorage) {\n      return localStorage.getItem(STORAGE_KEYS.DEMO_USER_LOGGED_IN) === 'true';\n    }\n    return false;\n  } catch (error) {\n    console.warn('Error accessing localStorage:', error);\n    return false;\n  }\n}\n\n/**\n * Generate mock user data for demo mode\n * @param {number} count - Number of users to generate\n * @returns {Array} - Array of mock user objects\n */\nfunction generateMockUsers(count = 50) {\n  const users = [];\n  const tiers = ['free', 'basic', 'pro', 'enterprise'];\n  const startDate = new Date(2023, 0, 1).getTime();\n  const endDate = new Date().getTime();\n  \n  for (let i = 0; i < count; i++) {\n    const createdAt = new Date(startDate + Math.random() * (endDate - startDate));\n    const lastLogin = new Date(createdAt.getTime() + Math.random() * (endDate - createdAt.getTime()));\n    \n    users.push({\n      id: `mock-${i}`,\n      email: `user${i}@example.com`,\n      name: `Test User ${i}`,\n      tier: tiers[Math.floor(Math.random() * tiers.length)],\n      created_at: createdAt.toISOString(),\n      active: Math.random() > 0.2,\n      last_login: lastLogin.toISOString()\n    });\n  }\n  \n  return users;\n}\n\n/**\n * Fetch all users with pagination\n * @param {number} page - The page number (1-indexed)\n * @param {number} pageSize - Number of records per page\n * @param {string} sortBy - Field to sort by\n * @param {string} sortOrder - 'asc' or 'desc'\n * @param {string} searchQuery - Optional search term to filter users\n * @returns {Promise<Object>} - Users data with pagination info\n */\nexport async function fetchUsers(page = 1, pageSize = 20, sortBy = 'created_at', sortOrder = 'desc', searchQuery = '') {\n  try {\n    // Check if we're in demo mode\n    if (isDemoMode()) {\n      if (import.meta.env.DEV) {\n        console.log('Using demo mode for admin users data');\n      }\n      \n      // Generate mock data for demo mode\n      let mockUsers = generateMockUsers();\n      \n      // Apply search filter if provided\n      if (searchQuery) {\n        const query = searchQuery.toLowerCase();\n        mockUsers = mockUsers.filter(user => \n          user.name.toLowerCase().includes(query) || \n          user.email.toLowerCase().includes(query)\n        );\n      }\n      \n      // Sort the data\n      mockUsers.sort((a, b) => {\n        const aValue = a[sortBy];\n        const bValue = b[sortBy];\n        \n        if (sortOrder === 'asc') {\n          return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;\n        } else {\n          return aValue > bValue ? -1 : aValue < bValue ? 1 : 0;\n        }\n      });\n      \n      // Apply pagination\n      const total = mockUsers.length;\n      const from = (page - 1) * pageSize;\n      const to = Math.min(from + pageSize, total);\n      const paginatedUsers = mockUsers.slice(from, to);\n      \n      return {\n        users: paginatedUsers,\n        pagination: {\n          total,\n          page,\n          pageSize,\n          totalPages: Math.ceil(total / pageSize),\n        }\n      };\n    }\n    \n    // If not in demo mode, proceed with Supabase authentication\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) throw new Error('Authentication required');\n\n    // Build the query\n    let query = supabase\n      .from('users')\n      .select('id, email, name, tier, created_at, active, last_login', { count: 'exact' });\n\n    // Add search query if provided\n    if (searchQuery) {\n      query = query.or(`name.ilike.%${searchQuery}%,email.ilike.%${searchQuery}%`);\n    }\n\n    // Add pagination and ordering\n    const from = (page - 1) * pageSize;\n    const to = from + pageSize - 1;\n\n    const { data, error, count } = await query\n      .order(sortBy, { ascending: sortOrder === 'asc' })\n      .range(from, to);\n\n    if (error) throw error;\n\n    return {\n      users: data,\n      pagination: {\n        total: count,\n        page,\n        pageSize,\n        totalPages: Math.ceil(count / pageSize),\n      }\n    };\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    throw error;\n  }\n}\n\n/**\n * Generate mock analytics data for demo mode\n * @returns {Object} - Mock analytics data\n */\nfunction generateMockAnalytics() {\n  const now = new Date();\n  const currentMonth = now.toLocaleString('default', { month: 'short' });\n  const previousMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1)\n    .toLocaleString('default', { month: 'short' });\n  \n  return {\n    userStats: {\n      total: 2475,\n      active: 1843,\n      newToday: 14,\n      growthRate: 8.2\n    },\n    revenueStats: {\n      monthly: 18650,\n      annually: 223800,\n      growth: 12.4,\n      averageRevenue: 75.2\n    },\n    userTiers: {\n      free: 1350,\n      basic: 740,\n      pro: 320,\n      enterprise: 65\n    },\n    monthlyTrends: {\n      users: [\n        { month: previousMonth, count: 2380 },\n        { month: currentMonth, count: 2475 }\n      ],\n      revenue: [\n        { month: previousMonth, amount: 17400 },\n        { month: currentMonth, amount: 18650 }\n      ],\n      engagement: [\n        { month: previousMonth, score: 83 },\n        { month: currentMonth, score: 87 }\n      ]\n    },\n    sessionStats: {\n      averageDuration: 840, // in seconds\n      totalSessions: 8720,\n      bounceRate: 23.5,\n      peak: '14:00-16:00'\n    },\n    feedbackStats: {\n      positive: 85.3,\n      negative: 14.7,\n      responseRate: 78.1\n    }\n  };\n}\n\n/**\n * Get analytics data for the admin dashboard\n * @returns {Promise<Object>} - Analytics data\n */\nexport async function fetchAdminAnalytics() {\n  try {\n    // Check if we're in demo mode\n    if (isDemoMode()) {\n      if (import.meta.env.DEV) {\n        console.log('Using demo mode for admin analytics data');\n      }\n      const mockData = generateMockAnalytics();\n      \n      // Store in cache for consistency\n      setCachedData(ADMIN_CACHE_KEYS.ANALYTICS, mockData, CACHE.TTL.ANALYTICS);\n      \n      return mockData;\n    }\n    \n    // Check cache first if not in demo mode\n    const cachedData = getCachedData(ADMIN_CACHE_KEYS.ANALYTICS);\n    if (cachedData) return cachedData;\n\n    // Authentication check\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) throw new Error('Authentication required');\n\n    // Fetch basic analytics data - in production this would use RPC\n    // or database views to efficiently compute server-side metrics\n    const [\n      { data: users, error: usersError },\n      { data: activeUsers, error: activeError },\n      { data: payments, error: paymentsError },\n      { data: sessions, error: sessionsError }\n    ] = await Promise.all([\n      // Total users\n      supabase.from('users').select('id', { count: 'exact' }),\n      \n      // Active users in the last 30 days\n      supabase\n        .from('users')\n        .select('id', { count: 'exact' })\n        .gte('last_login', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()),\n        \n      // Payments in the current month\n      supabase\n        .from('payments')\n        .select('amount')\n        .gte('created_at', new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString()),\n        \n      // Session data for average time\n      supabase\n        .from('user_sessions')\n        .select('duration')\n        .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()),\n    ]);\n    \n    if (usersError || activeError || paymentsError || sessionsError) {\n      throw new Error('Failed to fetch analytics data');\n    }\n\n    // Calculate monthly revenue\n    const monthlyRevenue = payments?.reduce((sum, payment) => sum + payment.amount, 0) || 0;\n    \n    // Calculate average session duration\n    const totalSessions = sessions?.length || 0;\n    const totalDuration = sessions?.reduce((sum, session) => sum + session.duration, 0) || 0;\n    const avgSessionTime = totalSessions > 0 ? Math.round(totalDuration / totalSessions) : 0;\n    \n    const formattedAvgTime = formatSessionTime(avgSessionTime);\n\n    const analyticsData = {\n      totalUsers: users?.count || 0,\n      activeUsers: activeUsers?.count || 0,\n      revenueThisMonth: monthlyRevenue,\n      averageSessionTime: formattedAvgTime,\n      lastUpdated: new Date().toISOString(),\n    };\n\n    // Cache the data\n    cacheData(ADMIN_CACHE_KEYS.ANALYTICS, analyticsData, 15 * 60 * 1000); // 15 minutes\n    \n    return analyticsData;\n  } catch (error) {\n    console.error('Error fetching admin analytics:', error);\n    \n    // Return backup demo data in case of error\n    return {\n      totalUsers: 156,\n      activeUsers: 129,\n      revenueThisMonth: 780,\n      averageSessionTime: '12m 42s',\n      chatQueriesPerDay: 428,\n      isDemo: true,\n    };\n  }\n}\n\n/**\n * Format session time in seconds to human-readable format\n * @param {number} timeInSeconds - Time in seconds\n * @returns {string} - Formatted time string\n */\nfunction formatSessionTime(timeInSeconds) {\n  if (timeInSeconds < 60) {\n    return `${timeInSeconds}s`;\n  }\n  \n  const minutes = Math.floor(timeInSeconds / 60);\n  const seconds = timeInSeconds % 60;\n  \n  if (minutes < 60) {\n    return `${minutes}m ${seconds}s`;\n  }\n  \n  const hours = Math.floor(minutes / 60);\n  const remainingMinutes = minutes % 60;\n  \n  return `${hours}h ${remainingMinutes}m`;\n}\n\n/**\n * Update user information (admin only)\n * @param {string} userId - User ID to update\n * @param {Object} updates - Fields to update\n * @returns {Promise<Object>} - Updated user data\n */\nexport async function updateUser(userId, updates) {\n  try {\n    // Authentication check and admin verification would happen here\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) throw new Error('Authentication required');\n    \n    // Only allow certain fields to be updated for security\n    const allowedFields = ['name', 'tier', 'active'];\n    const safeUpdates = {};\n    \n    // Filter only allowed fields\n    Object.keys(updates).forEach(key => {\n      if (allowedFields.includes(key)) {\n        safeUpdates[key] = updates[key];\n      }\n    });\n    \n    const { data, error } = await supabase\n      .from('users')\n      .update(safeUpdates)\n      .eq('id', userId)\n      .select()\n      .single();\n      \n    if (error) throw error;\n    \n    return data;\n  } catch (error) {\n    console.error('Error updating user:', error);\n    throw error;\n  }\n}\n\n/**\n * Get system settings\n * @returns {Promise<Object>} - System settings\n */\nexport async function getSystemSettings() {\n  try {\n    // Authentication check\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) throw new Error('Authentication required');\n    \n    const { data, error } = await supabase\n      .from('system_settings')\n      .select('*')\n      .single();\n      \n    if (error) {\n      // If no settings exist yet, return defaults\n      if (error.code === 'PGRST116') {\n        return {\n          maintenance_mode: false,\n          application_name: 'BoilerBrain',\n          support_email: 'support@boilerbrain.com',\n          max_file_size_mb: 10,\n          allow_registration: true,\n        };\n      }\n      throw error;\n    }\n    \n    return data;\n  } catch (error) {\n    console.error('Error fetching system settings:', error);\n    \n    // Return fallback settings in case of error\n    return {\n      maintenance_mode: false,\n      application_name: 'BoilerBrain',\n      support_email: 'support@boilerbrain.com',\n      max_file_size_mb: 10,\n      allow_registration: true,\n      isDemo: true,\n    };\n  }\n}\n\n/**\n * Update system settings\n * @param {Object} settings - System settings to update\n * @returns {Promise<Object>} - Updated settings\n */\nexport async function updateSystemSettings(settings) {\n  try {\n    // Authentication check\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) throw new Error('Authentication required');\n    \n    // In a real app, verify admin permissions here\n    \n    const { data, error } = await supabase\n      .from('system_settings')\n      .upsert({\n        id: 1, // Use fixed ID for singleton settings record\n        ...settings,\n        updated_at: new Date().toISOString(),\n      })\n      .select()\n      .single();\n      \n    if (error) throw error;\n    \n    return data;\n  } catch (error) {\n    console.error('Error updating system settings:', error);\n    throw error;\n  }\n}\n\nexport default {\n  fetchUsers,\n  fetchAdminAnalytics,\n  updateUser,\n  getSystemSettings,\n  updateSystemSettings,\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/utils/apiUtils.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'AbortController' is not defined.","line":16,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":17,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":17,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":20,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":25,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":25,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":40,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":77,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":77,"endColumn":48}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * API Utilities for BoilerBrain\n * Contains standardized functions for making API requests with proper error handling,\n * timeout management, and consistent response processing\n */\nimport { API } from './constants';\n\n/**\n * Creates an API request with standardized timeout and error handling\n * @param {string} url - The API endpoint URL\n * @param {Object} options - Fetch options (method, headers, body, etc.)\n * @param {number} timeoutMs - Timeout in milliseconds (default: 8000ms)\n * @returns {Promise<any>} - Response data or throws error\n */\nexport const fetchWithTimeout = async (url, options = {}, timeoutMs = API.TIMEOUT) => {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n  \n  try {\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal,\n    });\n    \n    clearTimeout(timeoutId);\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`API Error (${response.status}): ${errorText || response.statusText}`);\n    }\n    \n    // Check content type to determine how to parse response\n    const contentType = response.headers.get('content-type');\n    if (contentType && contentType.includes('application/json')) {\n      return await response.json();\n    } else {\n      return await response.text();\n    }\n  } catch (error) {\n    clearTimeout(timeoutId);\n    \n    if (error.name === 'AbortError') {\n      throw new Error(`Request timeout after ${timeoutMs}ms`);\n    }\n    \n    throw error;\n  }\n};\n\n/**\n * Standardized API request with retry logic\n * @param {string} url - The API endpoint URL\n * @param {Object} options - Fetch options\n * @param {number} maxRetries - Maximum number of retry attempts\n * @param {number} timeoutMs - Timeout in milliseconds\n * @param {function} onRetry - Optional callback function called on each retry attempt\n * @returns {Promise<any>} - Response data or throws error\n */\nexport const fetchWithRetry = async (url, options = {}, maxRetries = API.MAX_RETRIES, timeoutMs = API.TIMEOUT, onRetry = null) => {\n  let lastError = null;\n  \n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      // First attempt or retry\n      if (attempt > 0 && typeof onRetry === 'function') {\n        onRetry(attempt, lastError);\n      }\n      \n      return await fetchWithTimeout(url, options, timeoutMs);\n    } catch (error) {\n      lastError = error;\n      \n      // Don't wait if it's the last attempt\n      if (attempt < maxRetries) {\n        // Exponential backoff: 500ms, 1000ms, 2000ms, etc.\n        const backoffMs = Math.min(500 * Math.pow(2, attempt), API.BACKOFF_MAX);\n        await new Promise(resolve => setTimeout(resolve, backoffMs));\n      }\n    }\n  }\n  \n  // If we've exhausted all retries\n  throw lastError;\n};\n\n/**\n * Post JSON data to an API endpoint\n * @param {string} url - The API endpoint URL \n * @param {Object} data - Data to send as JSON\n * @param {Object} options - Additional fetch options\n * @param {number} maxRetries - Maximum number of retry attempts\n * @param {number} timeoutMs - Timeout in milliseconds\n * @returns {Promise<any>} - Response data or throws error\n */\nexport const postJsonData = async (url, data, options = {}, maxRetries = API.MAX_RETRIES, timeoutMs = API.TIMEOUT) => {\n  return fetchWithRetry(\n    url,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n      },\n      body: JSON.stringify(data),\n      ...options,\n    },\n    maxRetries,\n    timeoutMs,\n    options.onRetry\n  );\n};\n\n// Remove the default export to maintain consistency with other utility modules\n// and improve tree-shaking in the final bundle\n","usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/utils/boilerBrainLLMService.js","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":46,"fix":{"range":[302,302],"text":"\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":171,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":171,"endColumn":18,"suggestions":[{"fix":{"range":[6468,6602],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":174,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":174,"endColumn":18,"suggestions":[{"fix":{"range":[6633,6696],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":208,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":208,"endColumn":18,"suggestions":[{"fix":{"range":[7884,7944],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":212,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":212,"endColumn":16,"suggestions":[{"fix":{"range":[7985,8046],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'latestCorrection' is assigned a value but never used.","line":233,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":233,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'latestCorrection' is assigned a value but never used.","line":233,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":233,"endColumn":25},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":309,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":309,"endColumn":18,"suggestions":[{"fix":{"range":[11813,11865],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":331,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":331,"endColumn":19,"suggestions":[{"fix":{"range":[12370,12431],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":337,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":337,"endColumn":18,"suggestions":[{"fix":{"range":[12504,12555],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":396,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":396,"endColumn":18,"suggestions":[{"fix":{"range":[14209,14270],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":479,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":479,"endColumn":21},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":501,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":501,"endColumn":22,"suggestions":[{"fix":{"range":[18429,18509],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":509,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":509,"endColumn":48},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":517,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":517,"endColumn":18,"suggestions":[{"fix":{"range":[18967,19026],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\*.","line":555,"column":85,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":555,"endColumn":86,"suggestions":[{"messageId":"removeEscape","fix":{"range":[20828,20829],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[20828,20828],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'symptoms' is assigned a value but never used.","line":590,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":590,"endColumn":19,"suggestions":[{"messageId":"removeVar","data":{"varName":"symptoms"},"fix":{"range":[22379,22431],"text":""},"desc":"Remove unused variable 'symptoms'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'symptoms' is assigned a value but never used.","line":590,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":590,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'userMessage' is not defined.","line":653,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":653,"endColumn":46},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":665,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":665,"endColumn":18,"suggestions":[{"fix":{"range":[25538,25599],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":902,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":902,"endColumn":58,"suggestions":[{"messageId":"addBrackets","fix":{"range":[35862,37579],"text":"{ if (factCheckContext) {\n        return {\n          text: `Based on the technical information in our system schema for ${sessionContext.heatingSystemType || 'heating systems'}, I should clarify my previous response. ${factCheckContext}`,\n          factCheck: true,\n          systemTypeContext: sessionContext.heatingSystemType || null,\n          componentContext: sessionContext.currentComponent || null\n        };\n      }\n      \n      // If we have a fault code, prioritize that for diagnosis\n      if (sessionContext.faultCodes.length > 0) {\n        const faultData = await lookupFaultCode(sessionContext.faultCodes[0]);\n        if (faultData) {\n          return formatFaultCodeResponse(faultData);\n        } else {\n          return generateFaultCodeFallbackResponse(sessionContext.faultCodes[0]);\n        }\n      }\n      \n      // Otherwise, try to diagnose based on symptoms\n      const issueData = await lookupSymptomBasedIssues();\n      \n      // Check if we have relevant component information from the system schema\n      let componentContext = null;\n      if (sessionContext.currentComponent && sessionContext.componentSchema) {\n        const relevantComponent = Array.isArray(sessionContext.componentSchema) ?\n          sessionContext.componentSchema.find(c => c.component_name.toLowerCase() === sessionContext.currentComponent.toLowerCase()) :\n          null;\n          \n        if (relevantComponent) {\n          componentContext = relevantComponent;\n        }\n      }\n      \n      if (issueData && Array.isArray(issueData) && issueData.length > 0) {\n        return formatSymptomResponse(issueData, componentContext);\n      } else {\n        return generateSymptomFallbackResponse(componentContext);\n      } }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":905,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":905,"endColumn":35,"suggestions":[{"messageId":"addBrackets","fix":{"range":[35862,37579],"text":"{ if (factCheckContext) {\n        return {\n          text: `Based on the technical information in our system schema for ${sessionContext.heatingSystemType || 'heating systems'}, I should clarify my previous response. ${factCheckContext}`,\n          factCheck: true,\n          systemTypeContext: sessionContext.heatingSystemType || null,\n          componentContext: sessionContext.currentComponent || null\n        };\n      }\n      \n      // If we have a fault code, prioritize that for diagnosis\n      if (sessionContext.faultCodes.length > 0) {\n        const faultData = await lookupFaultCode(sessionContext.faultCodes[0]);\n        if (faultData) {\n          return formatFaultCodeResponse(faultData);\n        } else {\n          return generateFaultCodeFallbackResponse(sessionContext.faultCodes[0]);\n        }\n      }\n      \n      // Otherwise, try to diagnose based on symptoms\n      const issueData = await lookupSymptomBasedIssues();\n      \n      // Check if we have relevant component information from the system schema\n      let componentContext = null;\n      if (sessionContext.currentComponent && sessionContext.componentSchema) {\n        const relevantComponent = Array.isArray(sessionContext.componentSchema) ?\n          sessionContext.componentSchema.find(c => c.component_name.toLowerCase() === sessionContext.currentComponent.toLowerCase()) :\n          null;\n          \n        if (relevantComponent) {\n          componentContext = relevantComponent;\n        }\n      }\n      \n      if (issueData && Array.isArray(issueData) && issueData.length > 0) {\n        return formatSymptomResponse(issueData, componentContext);\n      } else {\n        return generateSymptomFallbackResponse(componentContext);\n      } }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-unreachable","severity":2,"message":"Unreachable code.","line":928,"column":3,"nodeType":"ExpressionStatement","messageId":"unreachableCode","endLine":930,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":928,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":928,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'response' is not defined.","line":930,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":930,"endColumn":18},{"ruleId":"no-prototype-builtins","severity":2,"message":"Do not access Object.prototype method 'hasOwnProperty' from target object.","line":945,"column":26,"nodeType":"CallExpression","messageId":"prototypeBuildIn","endLine":945,"endColumn":40,"suggestions":[{"messageId":"callObjectPrototype","data":{"prop":"hasOwnProperty"},"fix":{"range":[38292,38322],"text":"Object.prototype.hasOwnProperty.call(sessionContext, "},"desc":"Call Object.prototype.hasOwnProperty explicitly."}]}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/**\n * BoilerBrain LLM Service\n * \n * Implements an intelligent chat service for Gas Safe engineers\n * with fault diagnosis, symptom analysis, and context tracking\n * Integrates with component/system schema for accurate system-specific troubleshooting\n */\n\nimport { supabase } from '../supabaseClient';\nimport { TIME } from './constants';\nimport { systemSchema } from './systemSchemaLoader';\n\n// Session context tracker\nconst sessionContext = {\n  manufacturer: null,\n  model: null, \n  gcNumber: null,\n  symptoms: [],\n  faultCodes: [],\n  previousDiagnostics: [],\n  heatingSystemType: null, // 'combi', 'system', 'heat-only', 'back boiler'\n  systemComponents: [], // radiators, cylinder, tank, pump, etc.\n  conversationStage: 'initial', // initial, gathering, diagnosing, suggesting\n  messageCount: 0,\n  stepCounter: 0, // Tracks which diagnostic step we're on for chunked responses\n  diagnosticPath: [], // Stores the complete diagnostic path for reference\n  currentComponent: null, // Tracks which component is being diagnosed\n  componentSchema: null, // Stores the component schema for the current system type\n  corrections: [], // Tracks user corrections for fact-checking\n  history: [],\n  \n  // Reset context for a new conversation\n  reset() {\n    this.manufacturer = null;\n    this.model = null;\n    this.gcNumber = null;\n    this.symptoms = [];\n    this.faultCodes = [];\n    this.previousDiagnostics = [];\n    this.heatingSystemType = null;\n    this.systemComponents = [];\n    this.conversationStage = 'initial';\n    this.messageCount = 0;\n    this.stepCounter = 0;\n    this.diagnosticPath = [];\n    this.currentComponent = null;\n    this.componentSchema = null;\n    this.corrections = [];\n    this.history = [];\n  }\n};\n\n/**\n * Update context based on user message\n * Extracts key information like manufacturer, model, GC number, \n * heating system type, fault codes, symptoms, and user corrections\n * \n * @param {string} userMessage - Message from the user\n */\nfunction updateContext(userMessage) {\n  // Update message count\n  sessionContext.messageCount++;\n  \n  // Track the message in history\n  sessionContext.history.push({ role: 'user', content: userMessage });\n  \n  // Only track the last 10 messages to stay within token limits\n  if (sessionContext.history.length > 10) {\n    sessionContext.history = sessionContext.history.slice(-10);\n  }\n\n  // Check for corrections or contradictions\n  const correctionPatterns = [\n    /(?:no|incorrect|wrong|that(?:'s| is) not right|actually|in fact)/i,\n    /(?:that(?:'s| is) not how|doesn't work that way)/i,\n    /(?:you're|you are) (?:incorrect|wrong|mistaken)/i\n  ];\n  \n  const isCorrection = correctionPatterns.some(pattern => pattern.test(userMessage));\n  \n  if (isCorrection) {\n    // Store this as a correction for future fact-checking\n    sessionContext.corrections.push({\n      message: userMessage,\n      timestamp: Date.now()\n    });\n  }\n  \n  // Extract heating system type\n  const previousSystemType = sessionContext.heatingSystemType;\n  \n  if (!sessionContext.heatingSystemType || isCorrection) {\n    const heatingSystemPatterns = [\n      /(?:it's|its|have|got|a|using|with|my)\\s+(?:an?\\s+)?(combi|combination|system|heat[- ]only|back\\s*boiler|conventional)\\s+(?:boiler|system)/i,\n      /(?:heating|boiler)\\s+(?:system\\s+)?(?:is|type\\s+is)\\s+(?:an?\\s+)?(combi|combination|system|heat[- ]only|back\\s*boiler|conventional)/i\n    ];\n    \n    for (const pattern of heatingSystemPatterns) {\n      const match = userMessage.match(pattern);\n      if (match && match[1]) {\n        const typeMatch = match[1].toLowerCase();\n        if (typeMatch.includes('combi') || typeMatch.includes('combination')) {\n          sessionContext.heatingSystemType = 'combi';\n        } else if (typeMatch.includes('system')) {\n          sessionContext.heatingSystemType = 'system';\n        } else if (typeMatch.includes('heat') || typeMatch.includes('conventional')) {\n          sessionContext.heatingSystemType = 'heat-only';\n        } else if (typeMatch.includes('back')) {\n          sessionContext.heatingSystemType = 'back boiler';\n        }\n        break;\n      }\n    }\n\n    // Infer from context clues if not explicitly mentioned\n    if (!sessionContext.heatingSystemType) {\n      if (userMessage.toLowerCase().includes('instant hot water') || \n          userMessage.toLowerCase().includes('no cylinder') || \n          userMessage.toLowerCase().includes('direct hot water')) {\n        sessionContext.heatingSystemType = 'combi';\n      } else if (userMessage.toLowerCase().includes('hot water cylinder') && \n                !userMessage.toLowerCase().includes('cold water tank')) {\n        sessionContext.heatingSystemType = 'system';\n      } else if (userMessage.toLowerCase().includes('hot water cylinder') && \n                userMessage.toLowerCase().includes('cold water tank')) {\n        sessionContext.heatingSystemType = 'heat-only';\n      }\n    }\n  }\n\n  // If system type changed, load the appropriate component schema\n  if (sessionContext.heatingSystemType && \n      (sessionContext.heatingSystemType !== previousSystemType || !sessionContext.componentSchema)) {\n    loadSystemComponentSchema();\n  }\n  \n  // Update conversation stage if needed\n  if (sessionContext.conversationStage === 'initial' && sessionContext.messageCount > 1) {\n    sessionContext.conversationStage = 'gathering';\n  } else if (sessionContext.conversationStage === 'gathering' && \n            (sessionContext.manufacturer || sessionContext.model || sessionContext.faultCodes.length > 0)) {\n    sessionContext.conversationStage = 'diagnosing';\n  }\n  \n  // Extract mentioned system components\n  extractSystemComponents(userMessage);\n}\n\n/**\n * Load the component schema for the current heating system type\n */\nfunction loadSystemComponentSchema() {\n  if (!sessionContext.heatingSystemType) return;\n  \n  try {\n    // Convert heating system type to the format used in the schema\n    const schemaType = sessionContext.heatingSystemType\n      .toLowerCase()\n      .replace(/\\s+/g, '_')\n      .replace('-', '_');\n      \n    // Load components for this system type\n    sessionContext.componentSchema = systemSchema.getSystemComponents(schemaType);\n    \n    // Extract common component names for this system type\n    if (sessionContext.componentSchema && Array.isArray(sessionContext.componentSchema)) {\n      sessionContext.systemComponents = sessionContext.componentSchema.map(comp => comp.component_name);\n    }\n    \n    if (import.meta.env.DEV) {\n      console.log(`Loaded schema for ${sessionContext.heatingSystemType} system with ${sessionContext.systemComponents.length} components`);\n    }\n  } catch (error) {\n    console.error('Error loading system component schema:', error);\n  }\n}\n\n/**\n * Extract mentioned system components from user message\n * @param {string} userMessage - Message from the user\n */\nfunction extractSystemComponents(userMessage) {\n  if (!sessionContext.heatingSystemType || !sessionContext.componentSchema) return;\n  \n  try {\n    // Look for component names and aliases in the user message\n    if (Array.isArray(sessionContext.componentSchema)) {\n      for (const component of sessionContext.componentSchema) {\n        // Check for component name\n        if (userMessage.toLowerCase().includes(component.component_name.toLowerCase())) {\n          // Track this as the current component being discussed\n          sessionContext.currentComponent = component.component_name;\n          return;\n        }\n        \n        // Check aliases\n        if (component.known_aliases && Array.isArray(component.known_aliases)) {\n          for (const alias of component.known_aliases) {\n            if (userMessage.toLowerCase().includes(alias.toLowerCase().replace(/[\"\\\\[\\\\]]/g, ''))) {\n              sessionContext.currentComponent = component.component_name;\n              return;\n            }\n          }\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Error extracting system components:', error);\n  }\n  \n  if (import.meta.env.DEV) {\n    console.log('Current conversation context:', sessionContext);\n  }\n  return sessionContext;\n}\n\n/**\n * Lookup fault code in the database\n * \n * @param {string} faultCode - Fault code to lookup\n * @returns {Promise<object|null>} - Fault data or null if not found\n */\n/**\n * Perform fact-checking based on user corrections\n * @returns {Promise<string>} - Information for the LLM to incorporate into its next response\n */\nasync function factCheckCorrections() {\n  if (!sessionContext.corrections || sessionContext.corrections.length === 0) {\n    return '';\n  }\n  \n  // Only focus on the most recent correction for clarity\n  const latestCorrection = sessionContext.corrections[sessionContext.corrections.length - 1];\n  let factCheckInfo = '';\n  \n  try {\n    // Get the component information from the schema if available\n    if (sessionContext.currentComponent && sessionContext.componentSchema) {\n      // Find the component in the schema\n      const componentInfo = Array.isArray(sessionContext.componentSchema) ?\n        sessionContext.componentSchema.find(c => \n          c.component_name.toLowerCase() === sessionContext.currentComponent.toLowerCase()) :\n        null;\n      \n      if (componentInfo) {\n        factCheckInfo += `FACT-CHECK INFORMATION:\\n`;\n        factCheckInfo += `Component: ${componentInfo.component_name}\\n`;\n        \n        if (componentInfo.description) {\n          factCheckInfo += `Description: ${componentInfo.description}\\n`;\n        }\n        \n        if (componentInfo.function) {\n          factCheckInfo += `Function: ${componentInfo.function}\\n`;\n        }\n        \n        if (componentInfo.common_faults && Array.isArray(componentInfo.common_faults)) {\n          factCheckInfo += `Common faults:\\n`;\n          componentInfo.common_faults.forEach(fault => {\n            factCheckInfo += `- ${fault.fault_name}: ${fault.description}\\n`;\n            if (fault.symptoms && Array.isArray(fault.symptoms)) {\n              factCheckInfo += `  Symptoms: ${fault.symptoms.join(', ')}\\n`;\n            }\n          });\n        }\n        \n        if (componentInfo.diagnostic_tips && Array.isArray(componentInfo.diagnostic_tips)) {\n          factCheckInfo += `Diagnostic tips:\\n`;\n          componentInfo.diagnostic_tips.forEach(tip => {\n            factCheckInfo += `- ${tip}\\n`;\n          });\n        }\n      }\n    }\n    \n    // If we have a system type but no specific component, provide general system info\n    if (sessionContext.heatingSystemType && !factCheckInfo) {\n      const systemType = sessionContext.heatingSystemType\n        .toLowerCase()\n        .replace(/\\s+/g, '_')\n        .replace('-', '_');\n        \n      const systemData = systemSchema.loadSystemSchema()?.[systemType];\n      \n      if (systemData) {\n        factCheckInfo += `SYSTEM TYPE INFORMATION:\\n`;\n        factCheckInfo += `System type: ${sessionContext.heatingSystemType}\\n`;\n        \n        if (systemData.description) {\n          factCheckInfo += `Description: ${systemData.description}\\n`;\n        }\n        \n        if (systemData.key_characteristics && Array.isArray(systemData.key_characteristics)) {\n          factCheckInfo += `Key characteristics:\\n`;\n          systemData.key_characteristics.forEach(characteristic => {\n            factCheckInfo += `- ${characteristic}\\n`;\n          });\n        }\n      }\n    }\n    \n    // Add guidance for the AI on how to handle the correction\n    factCheckInfo += `\\nThe user has made a correction. Please: \\n`;\n    factCheckInfo += `1. Acknowledge the correction politely\\n`;\n    factCheckInfo += `2. Incorporate the above factual information into your response\\n`;\n    factCheckInfo += `3. Provide an improved, technically accurate response based on the system schema\\n`;\n    factCheckInfo += `4. Focus on being concise and precise in your diagnosis\\n`;\n  } catch (error) {\n    console.error('Error during fact checking:', error);\n  }\n  \n  return factCheckInfo;\n}\n\n/**\n * Lookup fault code in the database\n * \n * @param {string} faultCode - Fault code to lookup\n * @returns {Promise<object|null>} - Fault data or null if not found\n */\nasync function lookupFaultCode(faultCode) {\n  try {\n    const { data, error } = await supabase\n      .from('fault_codes')\n      .select('*')\n      .eq('manufacturer', sessionContext.manufacturer)\n      .eq('code', faultCode)\n      .limit(1);\n    \n    if (error || !data || data.length === 0) {\n      console.warn('Fault code not found in database:', faultCode);\n      return null;\n    }\n    \n    return data[0];\n  } catch (err) {\n    console.error('Error looking up fault code:', err);\n    return null;\n  }\n}\n\n/**\n * Lookup common issues for a specific model based on symptoms\n * \n * @returns {Promise<object|null>} - Issue data or null if not found\n */\nasync function lookupSymptomBasedIssues() {\n  try {\n    // First try with specific manufacturer and model\n    if (sessionContext.manufacturer && sessionContext.model) {\n      const { data, error } = await supabase\n        .from('common_issues')\n        .select('*')\n        .eq('manufacturer', sessionContext.manufacturer)\n        .eq('model', sessionContext.model)\n        .limit(10);\n      \n      if (!error && data && data.length > 0) {\n        // Filter by symptoms\n        const matchingIssues = data.filter(issue => \n          sessionContext.symptoms.some(symptom => \n            issue.symptoms.toLowerCase().includes(symptom.toLowerCase())\n          )\n        );\n        \n        if (matchingIssues.length > 0) {\n          return matchingIssues[0];\n        }\n      }\n    }\n    \n    // If that fails, try with just manufacturer\n    if (sessionContext.manufacturer) {\n      const { data, error } = await supabase\n        .from('common_issues')\n        .select('*')\n        .eq('manufacturer', sessionContext.manufacturer)\n        .limit(10);\n      \n      if (!error && data && data.length > 0) {\n        // Filter by symptoms\n        const matchingIssues = data.filter(issue => \n          sessionContext.symptoms.some(symptom => \n            issue.symptoms.toLowerCase().includes(symptom.toLowerCase())\n          )\n        );\n        \n        if (matchingIssues.length > 0) {\n          return matchingIssues[0];\n        }\n      }\n    }\n    \n    return null;\n  } catch (err) {\n    console.error('Error looking up symptom-based issues:', err);\n    return null;\n  }\n}\n\n/**\n * Handle initial conversation stage\n */\nfunction handleInitialInteraction() {\n  sessionContext.conversationStage = 'gathering';\n  \n  return {\n    text: \"Hi there. I'm BoilerBrain, here to help with your boiler diagnostics. To get started, could you tell me the make and model of the boiler you're working with? If you have the GC number handy, that would be helpful too.\",\n    source: 'ai_greeting'\n  };\n}\n\n/**\n * Request missing boiler identification information\n */\nfunction promptForBoilerInfo() {\n  if (!sessionContext.manufacturer) {\n    return {\n      text: \"Could you tell me which manufacturer made the boiler you're working on?\",\n      source: 'ai_request_manufacturer'\n    };\n  } else if (!sessionContext.model) {\n    return {\n      text: `Great, so it's a ${sessionContext.manufacturer} boiler. What's the specific model?`,\n      source: 'ai_request_model'\n    };\n  } else {\n    sessionContext.conversationStage = 'diagnosing';\n    return {\n      text: \"Thanks. Now, what symptoms are you seeing, or is there a fault code displayed?\",\n      source: 'ai_request_symptoms'\n    };\n  }\n}\n\n/**\n * Format response with fault code data\n * Now sends the database information to the OpenAI API for reasoning and synthesis\n * with improved error handling and retry logic\n * @param {object} faultData - Fault data from database\n * @returns {Promise<object>} Response with text and metadata\n */\nasync function formatFaultCodeResponse(faultData) {\n  try {\n    // Track retry attempts\n    let attempts = 0;\n    const maxAttempts = 2;\n    \n    while (attempts <= maxAttempts) {\n      try {\n        // Create a prompt that includes database info but requires reasoning\n        const systemMessage = {\n          role: \"system\",\n          content: `You are BoilerBrain, an expert heating engineer assistant. \n          You've found information about a fault code in your database, but you need to analyze and explain it using your expertise.\n          DO NOT just repeat the database text. Synthesize, reason, and explain using your engineering knowledge.\n          Consider component interactions, probable root causes, and system design aspects.\n          Use the database information as ONE input to your reasoning, not your entire response.`\n        };\n\n        const userMessage = {\n          role: \"user\",\n          content: `I'm working with a ${sessionContext.manufacturer} ${sessionContext.model} boiler with ${sessionContext.heatingSystemType ? `a ${sessionContext.heatingSystemType} system` : 'my heating system'}. \n          It's showing fault code ${faultData.code}. Based on your technical expertise and the available information, what's likely happening and how should I approach this?`\n        };\n\n        const assistantContext = {\n          role: \"assistant\",\n          content: `I found this in my technical database about fault code ${faultData.code}:\\n\\n\n          Issue description: ${faultData.description}\\n\\n\n          Troubleshooting steps: ${faultData.troubleshooting_steps}\\n\\n\n          ${faultData.safety_warning ? `Safety warning: ${faultData.safety_warning}\\n\\n` : ''}\n          \n          Now I'll analyze this situation using my heating engineering knowledge and explain what's likely happening and the best approach to fix it...`\n        };\n\n        // Increased timeout for API calls\n        const timeout = new Promise((_, reject) => {\n          setTimeout(() => reject(new Error('API request timed out')), 15000);\n        });\n        \n        // Call OpenAI API with timeout and return reasoned response\n        const apiCall = supabase.functions.invoke('openai-chat', {\n          body: {\n            messages: [systemMessage, userMessage, assistantContext],\n            model: \"gpt-4-turbo-preview\",\n            temperature: 0.2\n          }\n        });\n        \n        // Race between the API call and the timeout\n        const { data } = await Promise.race([apiCall, timeout]);\n\n        // If we got here, the call succeeded\n        return {\n          text: data.choices[0].message.content,\n          source: 'ai_synthesized_fault'\n        };\n      } catch (error) {\n        attempts++;\n        console.error(`API call attempt ${attempts}/${maxAttempts + 1} failed:`, error);\n        \n        // If this was our last attempt, throw to the outer catch block\n        if (attempts > maxAttempts) {\n          throw error;\n        }\n        \n        // Wait before retrying (exponential backoff)\n        await new Promise(resolve => setTimeout(resolve, 1000 * attempts));\n      }\n    }\n    \n    // Fallback if we somehow exit the while loop without returning\n    throw new Error('All retry attempts failed');\n    \n  } catch (error) {\n    console.error('Error synthesizing fault response:', error);\n    // Fallback to the old template method if API call fails\n    return {\n      text: `Fault Code: ${faultData.code}\\n\\nDescription: ${faultData.description}\\n\\nTroubleshooting Steps: ${faultData.troubleshooting_steps}\\n\\n${faultData.safety_warning ? `Safety Warning: ${faultData.safety_warning}\\n\\n` : ''}`,\n      source: 'database_fault'\n    };\n  }\n}\n\n/**\n * Generate fallback response when fault code isn't found\n */\nfunction generateFaultCodeFallbackResponse(faultCode) {\n  return {\n    text: `I couldn't find specific information about fault code ${faultCode} for ${sessionContext.manufacturer} ${sessionContext.model} in my database, but I can help based on general knowledge.\n\nFor ${sessionContext.manufacturer} boilers, this type of fault code often indicates an issue with:\n1. Ignition or flame detection\n2. Water pressure or flow problems\n3. Sensor/thermistor malfunctions\n\nLet's start with a basic check - is the boiler showing any other symptoms besides the fault code? For example, does it attempt to light and then shut down, or not attempt to light at all?`,\n    source: 'ai_fallback_fault'\n  };\n}\n\n/**\n * Format response with symptom-based issue data\n * Implements a step-by-step approach that only provides 1-2 steps at a time\n * @param {object} issueData - Issue data from database\n * @param {object} componentContext - Optional component schema information\n * @returns {Promise<object>} Response with text and metadata\n */\nasync function formatSymptomResponse(issueData, componentContext) {\n  try {\n    // Parse diagnostic steps into an array if it's not already\n    if (!sessionContext.diagnosticPath.length && issueData.diagnostic_steps) {\n      // Split steps by numbered lists or bullet points\n      const stepMatches = issueData.diagnostic_steps.match(/\\d+\\.\\s+[^\\d\\n]+|\\*\\s+[^\\*\\n]+/g) || [];\n      \n      if (stepMatches.length > 0) {\n        sessionContext.diagnosticPath = stepMatches.map(step => step.trim());\n      } else {\n        // If no clear steps found, split by sentences as a fallback\n        sessionContext.diagnosticPath = issueData.diagnostic_steps\n          .split('.')\n          .filter(s => s.trim().length > 0)\n          .map(s => s.trim() + '.');\n      }\n      \n      // Extract component being diagnosed (if mentioned)\n      const componentMatch = issueData.issue.match(/check the ([\\w\\s-]+)/i);\n      if (componentMatch) {\n        sessionContext.currentComponent = componentMatch[1].trim();\n      }\n    }\n    \n    // Create a prompt that includes database info but requires reasoning\n    // Now with step limiting\n    const systemMessage = {\n      role: \"system\",\n      content: `You are BoilerBrain, an expert heating engineer assistant.\n      You've found information about the reported symptoms in your database, but you need to provide guidance in small, manageable steps.\n      \n      CRITICAL INSTRUCTIONS:\n      - Provide ONLY 1-2 diagnostic steps in each response\n      - Be direct and concise - engineers need clarity, not excessive details\n      - Wait for the user to complete these steps before providing more\n      - If explaining a multi-step component check, break it into separate messages\n      - Acknowledge the system type (${sessionContext.heatingSystemType || 'unknown'}) and adapt advice accordingly\n      - Include appropriate safety warnings for each component check`\n    };\n\n    const symptoms = sessionContext.symptoms.join(', ');\n    \n    // Determine which steps to show in this response\n    const currentStepIndex = sessionContext.stepCounter;\n    \n    // Determine number of steps to show based on component complexity\n    const numStepsToShow = componentContext && componentContext.complexity === 'high' ? 1 : 2;\n    \n    let stepsToShow = [];\n    \n    if (currentStepIndex < sessionContext.diagnosticPath.length) {\n      // Select steps based on where we are in the process and complexity\n      stepsToShow = sessionContext.diagnosticPath.slice(\n        sessionContext.stepCounter,\n        sessionContext.stepCounter + numStepsToShow\n      );\n      \n      // Update step counter for next time\n      sessionContext.stepCounter += stepsToShow.length;\n      \n      // If we've reached the end, reset for follow-up diagnostics\n      if (sessionContext.stepCounter >= sessionContext.diagnosticPath.length) {\n        sessionContext.conversationStage = 'suggesting';\n      }\n    }\n    \n    // Include component-specific advice if available\n    let componentAdvice = '';\n    if (componentContext) {\n      if (componentContext.diagnostic_tips && Array.isArray(componentContext.diagnostic_tips)) {\n        componentAdvice = `\\n\\nBased on the system schema for ${sessionContext.heatingSystemType} systems, here's specific advice for the ${componentContext.component_name}:\\n`;\n        componentAdvice += componentContext.diagnostic_tips\n          .slice(0, 2)\n          .map(tip => `- ${tip}`)\n          .join('\\n');\n      }\n    }\n    \n    // Provide context about issue and some steps\n    const assistantContext = {\n      role: \"assistant\",\n      content: `Based on my analysis, the issue with your ${sessionContext.manufacturer} ${sessionContext.model} ${sessionContext.heatingSystemType ? `(${sessionContext.heatingSystemType} system)` : ''} is likely: ${issueData.issue}\n      \n      ${currentStepIndex === 0 ? \n        `Let's start diagnosing this step-by-step. Here's what to check first:` : \n        `Let's continue with the next diagnostic step:`}\n        \n      ${stepsToShow.length ? \n        stepsToShow.map((step, i) => `${i + 1}. ${step}`).join('\\n') : \n        \"We've gone through all the diagnostic steps. If the issue persists, let's try a different approach.\"}\n      \n      ${componentAdvice}\n      \n      ${currentStepIndex === 0 && issueData.parts_needed ? \n        `\\n\\nYou might eventually need these parts: ${issueData.parts_needed}, but let's diagnose first before replacing anything.` : \n        ''}\n        \n      Let me know what you find after completing ${stepsToShow.length > 1 ? 'these steps' : 'this step'}.`\n    };\n\n    // Call OpenAI API for synthesized response\n    const { data } = await supabase.functions.invoke('openai-chat', {\n      body: {\n        messages: [systemMessage, userMessage, assistantContext],\n        model: \"gpt-4-turbo-preview\",\n        temperature: 0.2\n      }\n    });\n\n    return {\n      text: data.choices[0].message.content,\n      source: 'ai_synthesized_symptoms',\n      hasMoreSteps: sessionContext.stepCounter < sessionContext.diagnosticPath.length\n    };\n  } catch (error) {\n    console.error('Error synthesizing symptom response:', error);\n    \n    // Fallback to simplified step-limiting approach\n    let fallbackResponse = \"\";\n    \n    if (sessionContext.diagnosticPath.length === 0) {\n      // First fallback response if we couldn't parse steps\n      fallbackResponse = `Based on the symptoms with your ${sessionContext.manufacturer} ${sessionContext.model}:\\n\\n\n      **Likely issue:** ${issueData.issue}\\n\\n\n      Let's approach this methodically. First, check for:\\n\\n\n      1. ${issueData.diagnostic_steps.split('.')[0]}.\\n\\n\n      Let me know what you find after checking this.`;\n    } else {\n      // Show next 1-2 steps if we already have parsed steps\n      const currentStepIndex = sessionContext.stepCounter;\n      const stepsToShow = sessionContext.diagnosticPath.slice(\n        currentStepIndex, \n        currentStepIndex + (sessionContext.diagnosticPath[currentStepIndex]?.length > 50 ? 1 : 2)\n      );\n      \n      sessionContext.stepCounter += stepsToShow.length;\n      \n      fallbackResponse = `Let's continue diagnosing your ${sessionContext.manufacturer} ${sessionContext.model}:\\n\\n\n      ${stepsToShow.map((step, i) => `${i + 1}. ${step}`).join('\\n')}\\n\\n\n      Let me know what you find after checking ${stepsToShow.length > 1 ? 'these items' : 'this'}.`;\n    }\n    \n    return {\n      text: fallbackResponse,\n      source: 'database_symptoms_fallback',\n      hasMoreSteps: sessionContext.stepCounter < sessionContext.diagnosticPath.length\n    };\n  }\n}\n\n/**\n * Generate system-specific troubleshooting advice based on heating system type\n */\nfunction getSystemSpecificAdvice(symptom) {\n  const type = sessionContext.heatingSystemType;\n  \n  const advice = {\n    'combi': {\n      'no hot water': 'For a combi boiler, check the diverter valve, plate heat exchanger, and flow sensor/turbine. These are common failure points for hot water issues.',\n      'no heating': 'For a combi boiler, verify the diverter valve is shifting to the heating position when there\\'s a demand. Also check the pump and heating circuit.',\n      'pressure': 'On combi boilers, pressure issues often relate to the auto air vent, expansion vessel, or pressure relief valve. There could also be a leak in the plate heat exchanger.'\n    },\n    'system': {\n      'no hot water': 'For a system boiler, check the cylinder thermostat, 3-way valve operation, and that the programmer is correctly configured for hot water timing.',\n      'no heating': 'On system boilers, verify the 3-way valve is directing flow to radiators when heating is demanded. Also check the pump and zone controls if installed.',\n      'pressure': 'For system boilers, check the expansion vessel in both the boiler and the unvented cylinder. Also inspect the pressure relief valve and tundish for discharge.'\n    },\n    'heat-only': {\n      'no hot water': 'For a heat-only boiler, check the cylinder thermostat, feed and expansion tank water levels, and motorized valve operation.',\n      'no heating': 'With heat-only boilers, check the external pump, motorized valves, and zone controls if fitted. Also verify header tank levels.',\n      'pressure': 'Heat-only boilers operate on an open-vented system - check feed and expansion tank levels and for airlocks in the gravity circuit.'\n    },\n    'back boiler': {\n      'no hot water': 'For back boilers, check the pilot light (if applicable), thermocouple, and ensure adequate ventilation around the fire/boiler unit.',\n      'no heating': 'Back boilers often use external pumps - check pump operation, thermostats, and that the fire front is operating correctly if integrated.',\n      'pressure': 'Back boilers typically use open-vented systems - check feed and expansion tank water levels and connections.'\n    }\n  };\n  \n  if (!type || !advice[type]) {\n    return '';\n  }\n  \n  // Match the symptom to an advice category\n  let adviceKey = 'no heating'; // Default\n  \n  if (symptom.includes('hot water') || symptom.includes('dhw')) {\n    adviceKey = 'no hot water';\n  } else if (symptom.includes('pressure') || symptom.includes('leak')) {\n    adviceKey = 'pressure';\n  }\n  \n  return advice[type][adviceKey] || '';\n}\n\n/**\n * Generate fallback response for symptom-based diagnosis\n * \n * @param {object} componentContext - Optional component schema information\n * @returns {Promise<object>} Fallback response\n */\nasync function generateSymptomFallbackResponse(componentContext) {\n  const symptoms = sessionContext.symptoms;\n  \n  // Include component-specific advice if available\n  let componentAdvice = '';\n  if (componentContext) {\n    if (componentContext.diagnostic_tips && Array.isArray(componentContext.diagnostic_tips)) {\n      componentAdvice = `\\n\\nBased on my knowledge of ${sessionContext.heatingSystemType || 'heating'} systems, here's specific advice for the ${componentContext.component_name}:\\n`;\n      componentAdvice += componentContext.diagnostic_tips\n        .slice(0, 2)\n        .map(tip => `- ${tip}`)\n        .join('\\n');\n    }\n  }\n  \n  // Determine if we have heating system context\n  const systemSpecific = sessionContext.heatingSystemType ? \n    getSystemSpecificAdvice() : \n    '';\n\n  // Check for specific symptoms to provide more targeted advice\n  if (symptoms.some(s => s.includes('no hot water') && s.includes('no heating'))) {\n    return {\n      text: `Based on the symptoms you're describing with your ${sessionContext.manufacturer || 'boiler'} ${sessionContext.model || ''} ${sessionContext.heatingSystemType ? `(${sessionContext.heatingSystemType} system)` : ''}, I'll help you troubleshoot no heating and no hot water.\n      \n      ${systemSpecific}\n      ${componentAdvice}\n      \n      Let's check these items first:\n      \n      1. Verify the power supply to the boiler is on and working\n      2. Check if the gas supply is on (try another gas appliance if possible)\n      3. Check the system pressure - it should typically be between 1-2 bar when cold\n      4. Look for any error codes on the boiler display\n      \n      What do you notice when you check these items?`,\n      source: 'ai_fallback_no_heat_water',\n      systemTypeContext: sessionContext.heatingSystemType || null,\n      componentContext: sessionContext.currentComponent || null\n    };\n  } else if (symptoms.some(s => s.includes('pressure') || s.includes('dropping'))) {\n    return {\n      text: `For your ${sessionContext.manufacturer || ''} ${sessionContext.model || 'boiler'} ${sessionContext.heatingSystemType ? `(${sessionContext.heatingSystemType} system)` : ''} with pressure issues, let's take a systematic approach:\n      \n      ${systemSpecific}\n      ${componentAdvice}\n      \n      1. Check for visible leaks around the boiler, pipework, and radiators\n      2. ${sessionContext.heatingSystemType === 'heat-only' ? 'Check feed and expansion tank water levels' : 'Inspect the pressure relief valve (PRV) - it may be discharging'}\n      3. ${sessionContext.heatingSystemType === 'heat-only' ? 'Look for airlocks in the system' : 'Check expansion vessel pressure - should be around 1 bar when system is cold and depressurized'}\n      4. Look for signs of internal heat exchanger leaks\n      \n      What do you notice when you check these items?`,\n      source: 'ai_fallback_pressure',\n      systemTypeContext: sessionContext.heatingSystemType || null,\n      componentContext: sessionContext.currentComponent || null\n    };\n  } else {\n    // Default case for general symptoms\n    return {\n      text: `Based on the symptoms you're describing with your ${sessionContext.manufacturer || 'boiler'} ${sessionContext.model || ''} ${sessionContext.heatingSystemType ? `(${sessionContext.heatingSystemType} system)` : ''}, I'd like to suggest a general troubleshooting approach.\n      \n      ${systemSpecific}\n      ${componentAdvice}\n      \n      Without more specific information, here are some common checks for boiler issues:\n      \n      1. Check that the boiler has power and any switches are turned on\n      2. Ensure the gas supply is on and working\n      3. Check the pressure gauge - it should typically be between 1 and 2 bar\n      4. Look for any visible error codes on the display\n      \n      If you can provide more detail about what's happening with your boiler, I can give more specific advice.`,\n      source: 'ai_fallback_symptoms',\n      systemTypeContext: sessionContext.heatingSystemType || null,\n      componentContext: sessionContext.currentComponent || null\n    };\n  }\n}\n\n/**\n * Process a user message and generate a response\n * \n * @param {Array} history - Chat history array\n * @returns {Promise<object>} - Response object with text and metadata\n */\nasync function processMessage(history) {\n  // Reset memory if new conversation\n  if (!history || history.length <= 1) {\n    sessionContext.reset();\n  }\n  \n  // Always keep the last message in history\n  const lastMessage = history && history.length > 0 ? history[history.length - 1] : null;\n  \n  if (!lastMessage || lastMessage.role !== 'user') {\n    return {\n      text: 'I\\'m sorry, I didn\\'t receive a message to process.'\n    };\n  }\n  \n  // Update context based on user's message\n  updateContext(lastMessage.content);\n  \n  // Check if this is a correction and we should perform fact-checking\n  let factCheckContext = '';\n  if (sessionContext.corrections && sessionContext.corrections.length > 0) {\n    // Only fact-check if the latest correction was from the current message\n    const latestCorrection = sessionContext.corrections[sessionContext.corrections.length - 1];\n    if (Date.now() - latestCorrection.timestamp < TIME.MINUTE_MS) {\n      factCheckContext = await factCheckCorrections();\n    }\n  }\n  \n  // Update system component schema if needed based on current context\n  if (sessionContext.heatingSystemType && !sessionContext.componentSchema) {\n    loadSystemComponentSchema();\n  }\n  \n  // Handle different conversation stages\n  switch (sessionContext.conversationStage) {\n    case 'initial':\n      return handleInitialInteraction();\n    case 'gathering':\n      // Check if we're missing crucial boiler info\n      if (!sessionContext.manufacturer && !sessionContext.model) {\n        return promptForBoilerInfo();\n      }\n      // Fall through to diagnosing if we have some information\n    case 'diagnosing':\n      // If we have a fact-check context from a user correction, address it first\n      if (factCheckContext) {\n        return {\n          text: `Based on the technical information in our system schema for ${sessionContext.heatingSystemType || 'heating systems'}, I should clarify my previous response. ${factCheckContext}`,\n          factCheck: true,\n          systemTypeContext: sessionContext.heatingSystemType || null,\n          componentContext: sessionContext.currentComponent || null\n        };\n      }\n      \n      // If we have a fault code, prioritize that for diagnosis\n      if (sessionContext.faultCodes.length > 0) {\n        const faultData = await lookupFaultCode(sessionContext.faultCodes[0]);\n        if (faultData) {\n          return formatFaultCodeResponse(faultData);\n        } else {\n          return generateFaultCodeFallbackResponse(sessionContext.faultCodes[0]);\n        }\n      }\n      \n      // Otherwise, try to diagnose based on symptoms\n      const issueData = await lookupSymptomBasedIssues();\n      \n      // Check if we have relevant component information from the system schema\n      let componentContext = null;\n      if (sessionContext.currentComponent && sessionContext.componentSchema) {\n        const relevantComponent = Array.isArray(sessionContext.componentSchema) ?\n          sessionContext.componentSchema.find(c => c.component_name.toLowerCase() === sessionContext.currentComponent.toLowerCase()) :\n          null;\n          \n        if (relevantComponent) {\n          componentContext = relevantComponent;\n        }\n      }\n      \n      if (issueData && Array.isArray(issueData) && issueData.length > 0) {\n        return formatSymptomResponse(issueData, componentContext);\n      } else {\n        return generateSymptomFallbackResponse(componentContext);\n      }\n    default:\n      return {\n        text: 'I\\'m having trouble understanding where we are in the diagnostic process. Can you tell me what issue you\\'re experiencing with your boiler?'\n      };\n  }\n  \n  // Simulate a brief thinking delay for a more natural conversation flow\n  await new Promise(resolve => setTimeout(resolve, TIME.SECOND / 2));\n  \n  return response;\n}\n\n// Public API\nexport const boilerBrainLLMService = {\n  processMessage,\n  \n  // Expose session context for persistence/debugging\n  getSessionContext() {\n    return { ...sessionContext };\n  },\n  \n  // Allow setting session context from saved state\n  restoreSessionContext(savedContext) {\n    Object.keys(savedContext).forEach(key => {\n      if (sessionContext.hasOwnProperty(key)) {\n        sessionContext[key] = savedContext[key];\n      }\n    });\n  },\n  \n  // Clear session context\n  clearSessionContext() {\n    sessionContext.reset();\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/utils/boilerBrainSystemPrompt.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/utils/cacheUtils.js","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":27,"fix":{"range":[169,169],"text":"\n"}},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":38,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":44,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":44,"endColumn":23},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":53,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":53,"endColumn":20,"suggestions":[{"fix":{"range":[1666,1729],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":78,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":78,"endColumn":19},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":80,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":80,"endColumn":20,"suggestions":[{"fix":{"range":[2465,2526],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":101,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":101,"endColumn":19},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":103,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":103,"endColumn":20,"suggestions":[{"fix":{"range":[3100,3164],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":124,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":124,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":126,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":126,"endColumn":37},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":128,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":128,"endColumn":20,"suggestions":[{"fix":{"range":[3787,3846],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":175,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":175,"endColumn":22,"suggestions":[{"fix":{"range":[5195,5238],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/**\n * Caching utility for BoilerBrain application\n * Provides memory caching with TTL (time-to-live) and localStorage persistence options\n */\nimport React from 'react';\nimport { CACHE } from './constants';\n\n// In-memory cache storage\nconst memoryCache = new Map();\n\n/**\n * Get a value from cache\n * @param {string} key - The cache key\n * @param {object} options - Cache options\n * @param {boolean} options.useLocalStorage - Whether to also check localStorage\n * @param {number} options.ttl - Time to live in milliseconds\n * @returns {any|null} - The cached value or null if not found/expired\n */\nexport const getCachedData = (key, options = {}) => {\n  const { useLocalStorage = false, ttl } = options;\n  \n  // Check memory cache first (faster)\n  if (memoryCache.has(key)) {\n    const cachedItem = memoryCache.get(key);\n    \n    // Check if item has expired\n    if (ttl && cachedItem.timestamp && Date.now() - cachedItem.timestamp > ttl) {\n      memoryCache.delete(key);\n      return null;\n    }\n    \n    return cachedItem.value;\n  }\n  \n  // Then check localStorage if specified\n  if (useLocalStorage) {\n    try {\n      const storedItem = localStorage.getItem(`${CACHE.PREFIX}${key}`);\n      if (storedItem) {\n        const parsedItem = JSON.parse(storedItem);\n        \n        // Check if localStorage item has expired\n        if (ttl && parsedItem.timestamp && Date.now() - parsedItem.timestamp > ttl) {\n          localStorage.removeItem(`${CACHE.PREFIX}${key}`);\n          return null;\n        }\n        \n        // Add back to memory cache and return\n        memoryCache.set(key, parsedItem);\n        return parsedItem.value;\n      }\n    } catch (error) {\n      console.error('Error reading from localStorage cache:', error);\n    }\n  }\n  \n  return null;\n};\n\n/**\n * Store a value in cache\n * @param {string} key - The cache key\n * @param {any} value - The value to cache\n * @param {object} options - Cache options\n * @param {boolean} options.useLocalStorage - Whether to also store in localStorage\n * @returns {void}\n */\nexport const setCachedData = (key, value, options = {}) => {\n  const { useLocalStorage = false } = options;\n  \n  // Store in memory cache\n  const timestamp = Date.now();\n  memoryCache.set(key, { value, timestamp });\n  \n  // Also store in localStorage if specified\n  if (useLocalStorage && value !== undefined) {\n    try {\n      localStorage.setItem(`${CACHE.PREFIX}${key}`, JSON.stringify({ value, timestamp }));\n    } catch (error) {\n      console.error('Error writing to localStorage cache:', error);\n    }\n  }\n};\n\n/**\n * Remove a value from cache\n * @param {string} key - The cache key\n * @param {object} options - Cache options\n * @param {boolean} options.useLocalStorage - Whether to also remove from localStorage\n * @returns {void}\n */\nexport const removeCachedData = (key, options = {}) => {\n  const { useLocalStorage = false } = options;\n  \n  // Remove from memory cache\n  memoryCache.delete(key);\n  \n  // Also remove from localStorage if specified\n  if (useLocalStorage) {\n    try {\n      localStorage.removeItem(`${CACHE.PREFIX}${key}`);\n    } catch (error) {\n      console.error('Error removing from localStorage cache:', error);\n    }\n  }\n};\n\n/**\n * Clear all cached data\n * @param {object} options - Cache options\n * @param {boolean} options.useLocalStorage - Whether to also clear localStorage\n * @returns {void}\n */\nexport const clearCache = (options = {}) => {\n  const { useLocalStorage = false } = options;\n  \n  // Clear memory cache\n  memoryCache.clear();\n  \n  // Also clear localStorage if specified\n  if (useLocalStorage) {\n    try {\n      // Only clear keys with our prefix\n      Object.keys(localStorage)\n        .filter(key => key.startsWith(CACHE.PREFIX))\n        .forEach(key => localStorage.removeItem(key));\n    } catch (error) {\n      console.error('Error clearing localStorage cache:', error);\n    }\n  }\n};\n\n/**\n * React hook for cached data with automatic refresh\n * @param {string} key - Cache key\n * @param {Function} fetchFn - Function to fetch data when not in cache\n * @param {object} options - Cache options\n * @returns {[any, boolean, Error|null]} - [data, loading, error]\n */\nexport function useCachedData(key, fetchFn, options = {}) {\n  const { \n    ttl = CACHE.DEFAULT_TTL,\n    useLocalStorage = false,\n    forceRefresh = false\n  } = options;\n  \n  const [data, setData] = React.useState(null);\n  const [loading, setLoading] = React.useState(true);\n  const [error, setError] = React.useState(null);\n  \n  React.useEffect(() => {\n    const loadData = async () => {\n      setLoading(true);\n      setError(null);\n      \n      try {\n        // Try to get from cache first, unless forcing refresh\n        if (!forceRefresh) {\n          const cachedData = getCachedData(key, { useLocalStorage, ttl });\n          \n          if (cachedData !== null) {\n            setData(cachedData);\n            setLoading(false);\n            return;\n          }\n        }\n        \n        // Not in cache or forcing refresh, fetch fresh data\n        const freshData = await fetchFn();\n        \n        // Store in cache and update state\n        setCachedData(key, freshData, { useLocalStorage });\n        setData(freshData);\n      } catch (err) {\n        console.error('Error fetching data:', err);\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    loadData();\n  }, [key, ttl, useLocalStorage, forceRefresh, fetchFn]);\n  \n  return [data, loading, error];\n}\n\n// Only export named exports for better tree-shaking and consistency\n// Remove the default export to avoid confusion\n","usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/utils/constants.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/utils/csrfUtils.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":12,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":17,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":17,"endColumn":19},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":23,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":23,"endColumn":18,"suggestions":[{"fix":{"range":[604,656],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":33,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":33,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":82,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":82,"endColumn":33},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":91,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":91,"endColumn":18,"suggestions":[{"fix":{"range":[2331,2374],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CSRF Token Utilities\n * Handles fetching, storing, and managing CSRF tokens for secure form submissions\n */\n\n/**\n * Fetches a new CSRF token from the server\n * @returns {Promise<string>} The CSRF token\n */\nexport const fetchCsrfToken = async () => {\n  try {\n    const response = await fetch('/api/csrf-token');\n    const data = await response.json();\n    \n    if (data.csrfToken) {\n      // Store token in localStorage for reuse\n      localStorage.setItem('csrfToken', data.csrfToken);\n      return data.csrfToken;\n    }\n    \n    throw new Error('No CSRF token returned');\n  } catch (error) {\n    console.error('Failed to fetch CSRF token:', error);\n    throw error;\n  }\n};\n\n/**\n * Gets the current CSRF token or fetches a new one if none exists\n * @returns {Promise<string>} The CSRF token\n */\nexport const getCsrfToken = async () => {\n  const storedToken = localStorage.getItem('csrfToken');\n  \n  if (storedToken) {\n    return storedToken;\n  }\n  \n  return fetchCsrfToken();\n};\n\n/**\n * Creates fetch options object with CSRF token header\n * @param {Object} options - Fetch options\n * @returns {Promise<Object>} Fetch options with CSRF token header\n */\nexport const withCsrfToken = async (options = {}) => {\n  const token = await getCsrfToken();\n  \n  return {\n    ...options,\n    headers: {\n      ...options.headers,\n      'X-CSRF-Token': token\n    }\n  };\n};\n\n/**\n * Uploads logs or screenshots securely with CSRF protection\n * \n * @param {string} logType - Type of log (e.g., 'error', 'screenshot', 'feedback')\n * @param {any} content - Content of the log or screenshot (can be text, base64, etc.)\n * @param {Object} userInfo - Optional user information\n * @returns {Promise<Object>} Response data\n */\nexport const uploadLog = async (logType, content, userInfo = null) => {\n  try {\n    const options = await withCsrfToken({\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        logType,\n        content,\n        timestamp: new Date().toISOString(),\n        userInfo\n      })\n    });\n    \n    const response = await fetch('/api/logs/upload', options);\n    \n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(errorData.error || 'Upload failed');\n    }\n    \n    return response.json();\n  } catch (error) {\n    console.error('Log upload failed:', error);\n    throw error;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/utils/demoApiService.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'TIME' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":14,"suggestions":[{"messageId":"removeVar","data":{"varName":"TIME"},"fix":{"range":[145,150],"text":""},"desc":"Remove unused variable 'TIME'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TIME' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":62,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":42}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Demo API Service\n * Simulates API responses for the demo environment\n * This allows the app to work without a backend server\n */\nimport { TIME, DEMO } from './constants';\n\nconst DEMO_RESPONSES = [\n  \"That's a common issue with Worcester Bosch models. In my experience, the pressure switch can get a bit temperamental. Have you checked if the pressure gauge is reading between 1 and 2 bar?\",\n  \n  \"Sounds like it could be a faulty diverter valve. Those symptoms are pretty classic for that problem. I'd check that first before digging any deeper.\",\n  \n  \"Hmm, if it's firing up but then cutting out after a few minutes, I'd be looking at either the flame sensor or maybe a blocked flue. Those are the usual suspects with Vaillant models.\",\n  \n  \"Yeah, with those Baxi units, they've got a common problem with the PCB. Sometimes it's just a loose connection, but it might need replacing if it's more than 5 years old.\",\n  \n  \"Hot water but no heating? That's almost always the diverter valve or the heating pump. Worth checking both - start with the pump, see if it's running when the heating is called for.\",\n  \n  \"Those symptoms sound like a classic airlock in the system. Have you tried bleeding the radiators? I'd start with the highest point in the system and work your way down.\",\n  \n  \"If it's making that knocking noise, it's probably kettling. That's usually caused by limescale build-up on the heat exchanger. A powerflush might sort it, but if it's an old system, you might be looking at a replacement.\",\n  \n  \"That's a bit of a tricky one. Given what you've described, I'd be checking the gas valve first. Those can get sticky and cause the intermittent heating you're describing.\",\n  \n  \"I've dealt with something similar last month. Turned out the condensate pipe had frozen over. It's a common problem in the winter. Try pouring some warm (not boiling) water over the external pipe.\",\n  \n  \"With those symptoms, I'd check the expansion vessel. If it's lost its charge, that would explain the pressure dropping. It's a relatively easy fix if that's the case.\"\n];\n\nconst DEMO_ANSWERS = {\n  \"how are you\": \"I'm doing great! Ready to help with any boiler or heating questions you might have. What can I assist you with today?\",\n  \n  \"what's your name\": \"I'm Dave, been working on boilers and heating systems for over 25 years now. What can I help you with?\",\n  \n  \"help\": \"I'm here to help with any boiler or heating system questions. You can ask me about troubleshooting problems, maintenance tips, or specific model information. What's the issue you're facing?\",\n  \n  \"my boiler isn't working\": \"Sorry to hear that. Could you give me a bit more detail? Is it not turning on at all, or is it turning on but not heating? And do you know what make and model it is?\",\n  \n  \"pressure dropping\": \"Pressure dropping is usually down to a few things: a leak somewhere in the system, a faulty expansion vessel, or just normal air release. First, check for any visible leaks around pipes, radiators, and the boiler itself. If it's dropping slowly over weeks, it's probably just normal. If it's rapid, we need to look at the expansion vessel or potential leaks.\",\n  \n  \"no hot water\": \"No hot water but heating works? That's often a diverter valve issue. If neither hot water nor heating works, check if the boiler's getting power and if the gas supply is on. Also worth checking if the programmer/timer is set correctly. What make of boiler is it?\",\n  \n  \"radiator cold\": \"If just one radiator is cold, it's likely air trapped (try bleeding it) or a stuck valve. If multiple radiators are cold, especially upper floors, you might need to check your circulation pump or increase the system pressure. Is it just one radiator or multiple?\",\n  \n  \"boiler making noise\": \"Boiler noises can be several things. A kettling sound (like boiling water) suggests limescale buildup on the heat exchanger. Gurgling might be trapped air. Banging or tapping could be pump issues or pipes expanding. Can you describe the noise a bit more?\"\n};\n\nconst GREETING_MESSAGES = [\n  \"Hi there! I'm Dave, your heating engineer assistant. How can I help you today?\",\n  \"Hello! I'm Dave, with 25+ years of experience in heating systems. What can I help you with?\",\n  \"Welcome to Boiler Brain! I'm Dave, your virtual heating engineer. What questions do you have about your system?\",\n  \"Good day! I'm Dave, here to help with any boiler or heating questions. What's on your mind?\"\n];\n\n/**\n * Sends a message to the demo API service and receives a simulated response\n * @param {Array} history - Chat history including the current message\n * @returns {Promise<string>} - The simulated response\n */\nexport async function sendMessage(history) {\n  // Add a small delay to simulate network request\n  await new Promise(resolve => setTimeout(resolve, DEMO.NETWORK_DELAY));\n  \n  // If this is the first message, return a greeting\n  if (history.length === 1) {\n    return getRandomItem(GREETING_MESSAGES);\n  }\n  \n  // Get the last user message\n  const lastUserMessage = history[history.length - 1].text.toLowerCase();\n  \n  // Check if we have a prepared answer for this query\n  for (const [keyword, response] of Object.entries(DEMO_ANSWERS)) {\n    if (lastUserMessage.includes(keyword)) {\n      return response;\n    }\n  }\n  \n  // Return a random response if no keyword matches\n  return getRandomItem(DEMO_RESPONSES);\n}\n\n/**\n * Helper function to get a random item from an array\n * @param {Array} array - The array to pick from\n * @returns {any} - A random item from the array\n */\nfunction getRandomItem(array) {\n  return array[Math.floor(Math.random() * array.length)];\n}\n\n// Export as an object for backward compatibility\nexport const demoApiService = {\n  sendMessage\n};\n\n// Default export for backward compatibility\nexport default demoApiService;\n","usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/utils/demoManualService.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":168,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":168,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":178,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":178,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":238,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":238,"endColumn":44},{"ruleId":"no-unused-vars","severity":1,"message":"'id' is defined but never used.","line":255,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":255,"endColumn":27,"suggestions":[{"messageId":"removeVar","data":{"varName":"id"},"fix":{"range":[7567,7569],"text":""},"desc":"Remove unused variable 'id'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'id' is defined but never used.","line":255,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":255,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":257,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":257,"endColumn":44}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Demo Manual Service - simulates manual finder API responses\n// This allows the app to work without requiring Supabase access\n\n// Mock data for boiler manuals\nconst DEMO_MANUALS = [\n  {\n    id: 1,\n    make: 'Worcester Bosch',\n    model: 'Greenstar 30i',\n    fuel_type: 'Gas',\n    upload_date: '2023-12-15T10:30:00Z',\n    description: 'Installation and servicing instructions for the Greenstar 30i condensing combi boiler',\n    file_url: 'https://example.com/manuals/worcester-greenstar-30i.pdf',\n    file_size: 4521984,\n    year: 2022,\n    downloads: 1254,\n    page_count: 68\n  },\n  {\n    id: 2,\n    make: 'Vaillant',\n    model: 'ecoTEC plus 835',\n    fuel_type: 'Gas',\n    upload_date: '2023-11-22T14:45:00Z',\n    description: 'User manual and installation guide for Vaillant ecoTEC plus 835 high efficiency combi boiler',\n    file_url: 'https://example.com/manuals/vaillant-ecotec-plus-835.pdf',\n    file_size: 3845120,\n    year: 2021,\n    downloads: 938,\n    page_count: 54\n  },\n  {\n    id: 3,\n    make: 'Baxi',\n    model: 'Platinum 28',\n    fuel_type: 'Gas',\n    upload_date: '2024-01-05T09:15:00Z',\n    description: 'Complete user and service guide for Baxi Platinum 28 combi boiler',\n    file_url: 'https://example.com/manuals/baxi-platinum-28.pdf',\n    file_size: 5242880,\n    year: 2023,\n    downloads: 756,\n    page_count: 72\n  },\n  {\n    id: 4,\n    make: 'Ideal',\n    model: 'Logic+ 30',\n    fuel_type: 'Gas',\n    upload_date: '2023-10-18T16:20:00Z',\n    description: 'Installation and service manual for Ideal Logic+ 30 combi boiler',\n    file_url: 'https://example.com/manuals/ideal-logic-plus-30.pdf',\n    file_size: 4194304,\n    year: 2022,\n    downloads: 1089,\n    page_count: 64\n  },\n  {\n    id: 5,\n    make: 'Viessmann',\n    model: 'Vitodens 100-W',\n    fuel_type: 'Gas',\n    upload_date: '2024-02-20T11:10:00Z',\n    description: 'Technical and user guide for Viessmann Vitodens 100-W wall-mounted gas condensing boiler',\n    file_url: 'https://example.com/manuals/viessmann-vitodens-100w.pdf',\n    file_size: 6291456,\n    year: 2023,\n    downloads: 625,\n    page_count: 84\n  },\n  {\n    id: 6,\n    make: 'Glow-worm',\n    model: 'Energy 30C',\n    fuel_type: 'Gas',\n    upload_date: '2023-09-05T13:40:00Z',\n    description: 'Installation and servicing instructions for Glow-worm Energy 30C condensing combination boiler',\n    file_url: 'https://example.com/manuals/glowworm-energy-30c.pdf',\n    file_size: 3670016,\n    year: 2021,\n    downloads: 712,\n    page_count: 58\n  },\n  {\n    id: 7,\n    make: 'Potterton',\n    model: 'Gold 28',\n    fuel_type: 'Gas',\n    upload_date: '2023-08-14T15:55:00Z',\n    description: 'User and installation guide for Potterton Gold 28 high efficiency combi boiler',\n    file_url: 'https://example.com/manuals/potterton-gold-28.pdf',\n    file_size: 4718592,\n    year: 2022,\n    downloads: 543,\n    page_count: 62\n  },\n  {\n    id: 8,\n    make: 'Alpha',\n    model: 'E-Tec Plus 28',\n    fuel_type: 'Gas',\n    upload_date: '2024-03-30T10:05:00Z',\n    description: 'Installation and service manual for Alpha E-Tec Plus 28 condensing combination boiler',\n    file_url: 'https://example.com/manuals/alpha-etec-plus-28.pdf',\n    file_size: 5033164,\n    year: 2023,\n    downloads: 318,\n    page_count: 70\n  },\n  {\n    id: 9,\n    make: 'Ariston',\n    model: 'Clas HE EVO 30',\n    fuel_type: 'Gas',\n    upload_date: '2023-11-08T14:25:00Z',\n    description: 'User and installation guide for Ariston Clas HE EVO 30 high efficiency boiler',\n    file_url: 'https://example.com/manuals/ariston-clas-he-evo-30.pdf',\n    file_size: 3932160,\n    year: 2021,\n    downloads: 429,\n    page_count: 60\n  },\n  {\n    id: 10,\n    make: 'Worcester Bosch',\n    model: 'Greenstar 8000 Life 30kW',\n    fuel_type: 'Gas',\n    upload_date: '2024-01-25T08:50:00Z',\n    description: 'Technical and user guide for Worcester Bosch Greenstar 8000 Life 30kW gas-fired condensing boiler',\n    file_url: 'https://example.com/manuals/worcester-greenstar-8000-life.pdf',\n    file_size: 7340032,\n    year: 2023,\n    downloads: 892,\n    page_count: 90\n  },\n  {\n    id: 11,\n    make: 'Grant',\n    model: 'Vortex Pro 26',\n    fuel_type: 'Oil',\n    upload_date: '2023-10-02T09:30:00Z',\n    description: 'Installation and servicing instructions for Grant Vortex Pro 26 oil-fired condensing boiler',\n    file_url: 'https://example.com/manuals/grant-vortex-pro-26.pdf',\n    file_size: 5767168,\n    year: 2022,\n    downloads: 276,\n    page_count: 76\n  },\n  {\n    id: 12,\n    make: 'Navien',\n    model: 'NCB 40',\n    fuel_type: 'Gas',\n    upload_date: '2024-04-10T13:15:00Z',\n    description: 'Installation and operation manual for Navien NCB 40 condensing combination boiler',\n    file_url: 'https://example.com/manuals/navien-ncb-40.pdf',\n    file_size: 4980736,\n    year: 2023,\n    downloads: 187,\n    page_count: 68\n  }\n];\n\nexport const demoManualService = {\n  // Get all unique manufacturers from the data\n  async getManufacturers() {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    // Get unique manufacturer names\n    const manufacturers = [...new Set(DEMO_MANUALS.map(manual => manual.make))].sort();\n    return manufacturers;\n  },\n  \n  // Search and filter manuals\n  async searchManuals({ query = '', manufacturer = '', sortBy = 'upload_date', order = 'desc' }) {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 800));\n    \n    let results = [...DEMO_MANUALS];\n    \n    // Apply text search filter\n    if (query) {\n      const searchLower = query.toLowerCase();\n      results = results.filter(manual => \n        manual.model.toLowerCase().includes(searchLower) || \n        manual.make.toLowerCase().includes(searchLower) ||\n        manual.description.toLowerCase().includes(searchLower)\n      );\n    }\n    \n    // Apply manufacturer filter\n    if (manufacturer) {\n      results = results.filter(manual => manual.make === manufacturer);\n    }\n    \n    // Apply sorting\n    results.sort((a, b) => {\n      // Handle different sort fields\n      if (sortBy === 'upload_date') {\n        return order === 'desc'\n          ? new Date(b.upload_date) - new Date(a.upload_date)\n          : new Date(a.upload_date) - new Date(b.upload_date);\n      }\n      \n      if (sortBy === 'downloads') {\n        return order === 'desc'\n          ? b.downloads - a.downloads\n          : a.downloads - b.downloads;\n      }\n      \n      if (sortBy === 'year') {\n        return order === 'desc'\n          ? b.year - a.year\n          : a.year - b.year;\n      }\n      \n      // Default sort by make/model\n      if (sortBy === 'make') {\n        const makeCompare = a.make.localeCompare(b.make);\n        return order === 'desc' ? -makeCompare : makeCompare;\n      }\n      \n      if (sortBy === 'model') {\n        const modelCompare = a.model.localeCompare(b.model);\n        return order === 'desc' ? -modelCompare : modelCompare;\n      }\n      \n      return 0;\n    });\n    \n    return results;\n  },\n  \n  // Simulate downloading a manual\n  async downloadManual(id) {\n    // Simulate network delay for \"download\"\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    \n    const manual = DEMO_MANUALS.find(m => m.id === id);\n    if (!manual) {\n      throw new Error('Manual not found');\n    }\n    \n    // In a real app, this would trigger a file download\n    // In demo mode, we just return success\n    return {\n      success: true,\n      message: `Downloaded ${manual.make} ${manual.model} manual successfully!`,\n      manual\n    };\n  },\n  \n  // Track manual views (simulated)\n  async trackManualView(id) {\n    // Quick operation, just simulate a short delay\n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    // In demo mode, no actual tracking occurs\n    return { success: true };\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/utils/demoSettingsService.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":22,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":30},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":27,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":27,"endColumn":20,"suggestions":[{"fix":{"range":[807,860],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":40,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":52,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":63,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":63,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":81,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":81,"endColumn":44},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":85,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":85,"endColumn":18,"suggestions":[{"fix":{"range":[2436,2497],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":98,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":98,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":116,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":116,"endColumn":44}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Demo Settings Service - simulates settings API responses for the demo environment\n * This allows the app to work without a backend server for development/demo purposes\n */\nimport { STORAGE_KEYS, DEMO, TIME } from './constants';\n\n// Default demo user settings\nconst DEFAULT_DEMO_SETTINGS = {\n  name: DEMO.USER.DEFAULT_NAME,\n  email: DEMO.USER.DEFAULT_EMAIL,\n  tier: DEMO.USER.DEFAULT_TIER,\n  notifications_enabled: true,\n  payment_method: 'Visa ending in 4242',\n  account_created: '2024-01-15'\n};\n\n/**\n * Initialize or get settings from localStorage\n * @returns {Object} The stored settings or default settings\n */\nconst getStoredSettings = () => {\n  const stored = localStorage.getItem(STORAGE_KEYS.DEMO_SETTINGS);\n  if (stored) {\n    try {\n      return JSON.parse(stored);\n    } catch (err) {\n      console.error('Error parsing stored settings:', err);\n      return DEFAULT_DEMO_SETTINGS;\n    }\n  }\n  return DEFAULT_DEMO_SETTINGS;\n};\n\n/**\n * Save settings to localStorage\n * @param {Object} settings - The settings to save\n * @returns {Object} The saved settings\n */\nconst saveSettings = (settings) => {\n  localStorage.setItem(STORAGE_KEYS.DEMO_SETTINGS, JSON.stringify(settings));\n  return settings;\n};\n\n// Named export for better consistency with other services\nexport const demoSettingsService = {\n  /**\n   * Get the user profile\n   * @returns {Promise<Object>} User profile data\n   */\n  async getUserProfile() {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, DEMO.CHAT.GREETING_DELAY));\n    return getStoredSettings();\n  },\n  \n  /**\n   * Update the user profile\n   * @param {Object} updates - The profile updates\n   * @returns {Promise<Object>} Updated user profile\n   */\n  async updateUserProfile(updates) {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, DEMO.CHAT.SIMULATED_DELAY));\n    \n    const currentSettings = getStoredSettings();\n    const updatedSettings = {\n      ...currentSettings,\n      ...updates\n    };\n    \n    return saveSettings(updatedSettings);\n  },\n  \n  /**\n   * Reset the user password (simulated)\n   * @param {string} password - The new password\n   * @returns {Promise<Object>} Success status\n   */\n  async resetPassword(password) {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, TIME.SECOND));\n    \n    // In a demo, we don't actually store the password\n    if (import.meta.env.DEV) {\n      console.log('Demo: Password would be updated to:', password);\n    }\n    \n    return { success: true, message: 'Password updated successfully' };\n  },\n  \n  /**\n   * Upgrade the user plan\n   * @param {string} newTier - The new plan tier\n   * @returns {Promise<Object>} Updated settings\n   */\n  async upgradePlan(newTier) {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 1.2 * TIME.SECOND));\n    \n    const currentSettings = getStoredSettings();\n    const updatedSettings = {\n      ...currentSettings,\n      tier: newTier\n    };\n    \n    return saveSettings(updatedSettings);\n  },\n  \n  /**\n   * Update notification preferences\n   * @param {boolean} enabled - Whether notifications are enabled\n   * @returns {Promise<Object>} Updated settings\n   */\n  async updateNotifications(enabled) {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 0.6 * TIME.SECOND));\n    \n    const currentSettings = getStoredSettings();\n    const updatedSettings = {\n      ...currentSettings,\n      notifications_enabled: enabled\n    };\n    \n    return saveSettings(updatedSettings);\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/utils/engineerChatService.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'history' is defined but never used.","line":227,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":227,"endColumn":47,"suggestions":[{"messageId":"removeVar","data":{"varName":"history"},"fix":{"range":[7367,7376],"text":""},"desc":"Remove unused variable 'history'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'history' is defined but never used.","line":227,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":227,"endColumn":47},{"ruleId":"no-unused-vars","severity":1,"message":"'describeSymptoms' is assigned a value but never used.","line":420,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":420,"endColumn":23,"suggestions":[{"messageId":"removeVar","data":{"varName":"describeSymptoms"},"fix":{"range":[17563,18271],"text":""},"desc":"Remove unused variable 'describeSymptoms'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'describeSymptoms' is assigned a value but never used.","line":420,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":420,"endColumn":23},{"ruleId":"no-unused-vars","severity":1,"message":"'model' is assigned a value but never used.","line":444,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":444,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"model"},"fix":{"range":[18390,18397],"text":""},"desc":"Remove unused variable 'model'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'model' is assigned a value but never used.","line":444,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":444,"endColumn":30},{"ruleId":"no-unused-vars","severity":1,"message":"'symptoms' is assigned a value but never used.","line":444,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":444,"endColumn":52,"suggestions":[{"messageId":"removeVar","data":{"varName":"symptoms"},"fix":{"range":[18409,18419],"text":""},"desc":"Remove unused variable 'symptoms'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'symptoms' is assigned a value but never used.","line":444,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":444,"endColumn":52},{"ruleId":"no-undef","severity":2,"message":"'getWorcesterFaultDescription' is not defined.","line":451,"column":127,"nodeType":"Identifier","messageId":"undef","endLine":451,"endColumn":155},{"ruleId":"no-undef","severity":2,"message":"'getVaillantFaultDescription' is not defined.","line":453,"column":99,"nodeType":"Identifier","messageId":"undef","endLine":453,"endColumn":126},{"ruleId":"no-undef","severity":2,"message":"'getGenericFaultDescription' is not defined.","line":455,"column":77,"nodeType":"Identifier","messageId":"undef","endLine":455,"endColumn":103},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":507,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":507,"endColumn":44},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":540,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":540,"endColumn":18,"suggestions":[{"fix":{"range":[24829,25092],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Advanced Engineer Chat Service for Boiler Brain\n// Provides natural, helpful assistance for engineers troubleshooting boilers\n\n// Store comprehensive conversation context between messages\nlet conversationContext = {\n  // Detailed tracking of conversation state\n  messageCount: 0,\n  manufacturer: null,\n  model: null,\n  faultCodes: [],\n  symptoms: [],\n  attemptedFixes: [],\n  lastQuestion: null,\n  completeHistory: [], // Store complete message history\n  \n  // Memory of topics covered to avoid repetition\n  topicsCovered: {\n    askedAboutManufacturer: false,\n    askedAboutModel: false,\n    askedAboutFaultCode: false,\n    askedAboutSymptoms: false,\n    askedAboutAttemptedFixes: false,\n    providedMainAdvice: false\n  },\n  \n  // Track user sentiment and conversation flow\n  userFrustrationLevel: 0,  // 0-5 scale\n  conversationStage: 'initial', // initial, information-gathering, troubleshooting, resolution\n  lastResponseType: null,\n  \n  // Reset context for new conversations\n  reset() {\n    this.messageCount = 0;\n    this.manufacturer = null;\n    this.model = null;\n    this.faultCodes = [];\n    this.symptoms = [];\n    this.attemptedFixes = [];\n    this.lastQuestion = null;\n    this.completeHistory = [];\n    \n    this.topicsCovered = {\n      askedAboutManufacturer: false,\n      askedAboutModel: false,\n      askedAboutFaultCode: false,\n      askedAboutSymptoms: false,\n      askedAboutAttemptedFixes: false,\n      providedMainAdvice: false\n    };\n    \n    this.userFrustrationLevel = 0;\n    this.conversationStage = 'initial';\n    this.lastResponseType = null;\n  }\n};\n\n// Engineer phrases organized by conversation stage and sentiment\nconst ENGINEER_PHRASES = {\n  greeting: [\n    \"Hey there! \",\n    \"Hi! How can I help you today? \",\n    \"Hey! What boiler issue are we looking at today? \",\n    \"Hi there! Let's solve your boiler problem together! \"\n  ],\n  positive: [\n    \"Great! \",\n    \"Perfect! \",\n    \"Awesome! \",\n    \"Excellent!  \",\n    \"That's helpful! \"\n  ],\n  technical: [\n    \"\",\n    \"Based on what I know, \",\n    \"From my experience, \",\n    \"Looking at what you've described, \",\n    \"Thinking about your situation, \"\n  ],\n  empathetic: [\n    \"I totally get how frustrating that can be. \",\n    \"Oh no! That doesn't sound fun at all. \",\n    \"I can imagine how annoying that must be! \",\n    \"That's definitely a pain to deal with.  \"\n  ],\n  conclusion: [\n    \"Hope that sorts you out!  \",\n    \"Does that make sense? Let me know! \",\n    \"Let me know how you get on with that! \",\n    \"Anything else you need help with? I'm here!  \"\n  ]\n};\n\n// Add an authentic engineer phrase to the response based on context\nconst addEngineerPhrase = (response, type = 'technical') => {\n  // Don't always add a phrase to keep responses varied\n  if (Math.random() < 0.7) {\n    const phraseArray = ENGINEER_PHRASES[type] || ENGINEER_PHRASES.technical;\n    const phrase = phraseArray[Math.floor(Math.random() * phraseArray.length)];\n    \n    // Add phrase at beginning or end based on type\n    if (type === 'greeting') {\n      return `${phrase} ${response}`;\n    } else {\n      return `${response} ${phrase}`;\n    }\n  }\n  return response;\n};\n\n// Advanced information extraction to improve context understanding\nconst extractBoilerInfo = (message) => {\n  const info = {};\n  const msgLower = message.toLowerCase();\n  \n  // Common boiler manufacturers with various spellings\n  const manufacturers = {\n    'worcester': 'Worcester Bosch',\n    'bosch': 'Worcester Bosch',\n    'worcester bosch': 'Worcester Bosch',\n    'vaillant': 'Vaillant',\n    'baxi': 'Baxi',\n    'ideal': 'Ideal',\n    'ideal boilers': 'Ideal', \n    'glow worm': 'Glow Worm',\n    'glowworm': 'Glow Worm',\n    'potterton': 'Potterton',\n    'ariston': 'Ariston',\n    'viessmann': 'Viessmann',\n    'valliant': 'Vaillant', // common misspelling\n    'alpha': 'Alpha Heating',\n    'ferroli': 'Ferroli',\n    'intergas': 'Intergas',\n    'navien': 'Navien',\n    'johnson & starley': 'Johnson & Starley',\n    'johnson and starley': 'Johnson & Starley'\n  };\n  \n  // Find manufacturer mentions\n  for (const [key, value] of Object.entries(manufacturers)) {\n    if (msgLower.includes(key)) {\n      info.manufacturer = value;\n      break;\n    }\n  }\n  \n  // Extract model numbers - look for patterns that resemble model numbers\n  // Try multiple patterns to catch more model mentions\n  const modelPatterns = [\n    /\\b(?:model|type)\\s+([a-z0-9]+-?[a-z0-9]+|[a-z][0-9]{1,3})/i,\n    /\\b(ecomax|ecotec|logic|vogue|combi|system|i-?series|i[0-9]{1,3}|eco[0-9]{1,3}|cv[0-9]{1,3}|cdi|hri)\\b/i,\n    /\\b([a-z0-9]+-?[0-9]+(?:-?[a-z0-9]+)?)\\s+(?:boiler|model|system)\\b/i,\n    /\\b(?:it'?s\\s+(?:an?|the)\\s+)([a-z][0-9]+(?:-[a-z0-9]+)?|[a-z]+-?[0-9]+|[a-z0-9]+-?[0-9]+(?:-[a-z0-9]+)?)\\b/i\n  ];\n  \n  for (const pattern of modelPatterns) {\n    const modelMatch = msgLower.match(pattern);\n    if (modelMatch) {\n      info.model = modelMatch[1].toUpperCase();\n      break;\n    }\n  }\n  \n  // Look for fault codes with broader pattern matching\n  const faultCodePatterns = [\n    /(?:fault|error|code)\\s*(?:is|:|=)?\\s*([a-z][0-9]{1,2}|[a-f][0-9][0-9]?|[0-9]{1,3})/i,\n    /\\b([a-z][0-9]{1,2}|[0-9]{1,3})\\s+(?:fault|error|code)\\b/i,\n    /\\b(e[0-9]{1,3}|f[0-9]{1,2}|a[0-9]{1,2}|c[0-9]{1,2})\\b/i\n  ];\n  \n  for (const pattern of faultCodePatterns) {\n    const match = msgLower.match(pattern);\n    if (match) {\n      info.faultCode = match[1].toUpperCase();\n      break;\n    }\n  }\n  \n  // Extract common boiler symptoms\n  const symptoms = {\n    noHeat: [\"no heat\", \"not heating\", \"won't heat\", \"cold\", \"not getting hot\"],\n    noHotWater: [\"no hot water\", \"cold water\", \"not heating water\"],\n    leaking: [\"leak\", \"leaking\", \"water coming out\", \"dripping\"],\n    noise: [\"noise\", \"loud\", \"banging\", \"knocking\", \"gurgling\", \"kettling\", \"whistling\"],\n    pressure: [\"pressure\", \"low pressure\", \"high pressure\", \"dropping pressure\"],\n    flame: [\"no flame\", \"pilot light\", \"flame failure\", \"won't ignite\", \"not lighting\"],\n    lockout: [\"locked out\", \"lockout\", \"reset\", \"keeps cutting out\"]\n  };\n  \n  info.symptoms = [];\n  for (const [symptom, keywords] of Object.entries(symptoms)) {\n    for (const keyword of keywords) {\n      if (msgLower.includes(keyword)) {\n        info.symptoms.push(symptom);\n        break;\n      }\n    }\n  }\n  \n  // Extract attempted fixes\n  const fixes = {\n    reset: [\"reset\", \"restarted\", \"turned off and on\", \"power cycled\"],\n    pressure: [\"topped up pressure\", \"increased pressure\", \"adjusted pressure\"],\n    bled: [\"bled radiators\", \"bled system\", \"removed air\"],\n    filter: [\"cleaned filter\", \"checked filter\"],\n    thermostat: [\"checked thermostat\", \"adjusted thermostat\", \"turned up thermostat\"]\n  };\n  \n  info.attemptedFixes = [];\n  for (const [fix, keywords] of Object.entries(fixes)) {\n    for (const keyword of keywords) {\n      if (msgLower.includes(keyword)) {\n        info.attemptedFixes.push(fix);\n        break;\n      }\n    }\n  }\n  \n  // Detect user frustration\n  const frustrationKeywords = [\"frustrated\", \"annoying\", \"ridiculous\", \"useless\", \"waste of time\", \"fed up\", \"not working\", \"still not working\", \"again\", \"keep having\", \"same problem\", \"tried everything\"];\n  \n  info.frustrationDetected = frustrationKeywords.some(keyword => msgLower.includes(keyword));\n  \n  return info;\n};\n\n// Advanced response generator that maintains natural conversation flow\nconst generateResponse = (messageText, history) => {\n  // Check if this is a simple greeting and not the first message\n  const simpleGreetings = ['hi', 'hello', 'hey', 'morning', 'afternoon', 'evening', 'yo'];\n  if (conversationContext.messageCount > 0 && \n      simpleGreetings.includes(messageText.toLowerCase().trim())) {\n    // If user is just saying hi after conversation started, don't repeat greeting\n    return addEngineerPhrase(\"What boiler issue are we looking at today?\", 'technical');\n  }\n  \n  // Extract useful information from the message\n  const extractedInfo = extractBoilerInfo(messageText);\n  \n  // Increment message counter to track conversation length\n  conversationContext.messageCount++;\n  \n  // Update context with any extracted information\n  // Always update manufacturer if detected in latest message (allow changes)\n  if (extractedInfo.manufacturer) {\n    conversationContext.manufacturer = extractedInfo.manufacturer;\n    conversationContext.topicsCovered.askedAboutManufacturer = true;\n  }\n  \n  // Always update model if detected in latest message\n  if (extractedInfo.model) {\n    conversationContext.model = extractedInfo.model;\n    conversationContext.topicsCovered.askedAboutModel = true;\n  }\n  \n  if (extractedInfo.faultCode && !conversationContext.faultCodes.includes(extractedInfo.faultCode)) {\n    conversationContext.faultCodes.push(extractedInfo.faultCode);\n    conversationContext.topicsCovered.askedAboutFaultCode = true;\n  }\n  \n  // Add any detected symptoms\n  if (extractedInfo.symptoms && extractedInfo.symptoms.length > 0) {\n    extractedInfo.symptoms.forEach(symptom => {\n      if (!conversationContext.symptoms.includes(symptom)) {\n        conversationContext.symptoms.push(symptom);\n      }\n    });\n    conversationContext.topicsCovered.askedAboutSymptoms = true;\n  }\n  \n  // Add attempted fixes\n  if (extractedInfo.attemptedFixes && extractedInfo.attemptedFixes.length > 0) {\n    extractedInfo.attemptedFixes.forEach(fix => {\n      if (!conversationContext.attemptedFixes.includes(fix)) {\n        conversationContext.attemptedFixes.push(fix);\n      }\n    });\n    conversationContext.topicsCovered.askedAboutAttemptedFixes = true;\n  }\n  \n  // Update user frustration level if detected\n  if (extractedInfo.frustrationDetected) {\n    conversationContext.userFrustrationLevel = Math.min(5, conversationContext.userFrustrationLevel + 1);\n  } else {\n    conversationContext.userFrustrationLevel = Math.max(0, conversationContext.userFrustrationLevel - 0.5);\n  }\n  \n  // Update conversation stage based on information gathered\n  if (conversationContext.messageCount <= 1) {\n    conversationContext.conversationStage = 'initial';\n  } else if (conversationContext.manufacturer && conversationContext.symptoms.length > 0) {\n    conversationContext.conversationStage = 'troubleshooting';\n  } else if (conversationContext.topicsCovered.providedMainAdvice) {\n    conversationContext.conversationStage = 'resolution';\n  } else {\n    conversationContext.conversationStage = 'information-gathering';\n  }\n  \n  //--------------------------------------------------------------------------\n  // Generate appropriate response based on conversation stage and context\n  //--------------------------------------------------------------------------\n  \n  // First message - greeting\n  if (conversationContext.messageCount <= 1) {\n    conversationContext.lastQuestion = 'initial';\n    return addEngineerPhrase(\"Hey there! I'm your friendly BoilerBrain assistant. What make and model of boiler are we looking at today? \", 'greeting');\n  }\n  \n  // If user is showing frustration, acknowledge it\n  if (conversationContext.userFrustrationLevel >= 3) {\n    const empathyResponse = \"I understand this can be frustrating. Let me help you get this sorted out. \";\n    conversationContext.userFrustrationLevel -= 1; // Reduce frustration after acknowledging\n    \n    // After empathy, continue with regular response flow but with added empathy\n    if (!conversationContext.manufacturer) {\n      conversationContext.lastQuestion = 'manufacturer';\n      return addEngineerPhrase(empathyResponse + \"What make of boiler is it that we're looking at?\", 'empathetic');\n    }\n  }\n  \n  // If we're missing the manufacturer, ask for it\n  if (!conversationContext.manufacturer) {\n    conversationContext.lastQuestion = 'manufacturer';\n    return addEngineerPhrase(\"To help you properly, I'd need to know what make of boiler you have. Worcester Bosch? Vaillant? Ideal?\", 'technical');\n  }\n  \n  // If we have the manufacturer but no model, ask about the model first\n  if (conversationContext.manufacturer && !conversationContext.model && !conversationContext.topicsCovered.askedAboutModel) {\n    conversationContext.topicsCovered.askedAboutModel = true;\n    conversationContext.lastQuestion = 'model';\n    return addEngineerPhrase(`A ${conversationContext.manufacturer}, great. Which specific model is it?`, 'technical');\n  }\n  \n  // If we have the manufacturer but no symptoms or fault codes\n  if (conversationContext.manufacturer && conversationContext.symptoms.length === 0 && conversationContext.faultCodes.length === 0) {\n    conversationContext.lastQuestion = 'symptoms';\n    return addEngineerPhrase(`Thanks for that info. What seems to be the problem with your ${conversationContext.manufacturer}${conversationContext.model ? ' ' + conversationContext.model : ''}? Any issues with heating, hot water, or strange noises?`, 'technical');\n  }\n  \n  // If we have symptoms but no fault code, ask if there's a fault code\n  if (conversationContext.symptoms.length > 0 && conversationContext.faultCodes.length === 0 && !conversationContext.topicsCovered.askedAboutFaultCode) {\n    conversationContext.topicsCovered.askedAboutFaultCode = true;\n    conversationContext.lastQuestion = 'faultCode';\n    return addEngineerPhrase(`I see. And is the boiler showing any fault codes or error messages on the display?`, 'technical');\n  }\n  \n  // If we have a fault code but haven't asked about attempted fixes\n  if (conversationContext.faultCodes.length > 0 && !conversationContext.topicsCovered.askedAboutAttemptedFixes) {\n    conversationContext.topicsCovered.askedAboutAttemptedFixes = true;\n    conversationContext.lastQuestion = 'fixes';\n    return addEngineerPhrase(`That fault code gives us a good starting point. Have you already tried anything to resolve it, like resetting the boiler or checking the pressure?`, 'technical');\n  }\n  \n  // Provide targeted advice based on the information we have\n  if (conversationContext.conversationStage === 'troubleshooting' && !conversationContext.topicsCovered.providedMainAdvice) {\n    conversationContext.topicsCovered.providedMainAdvice = true;\n    return generateAdvice();\n  }\n  \n  // If we've already provided advice, handle follow-up conversation properly\n  if (conversationContext.topicsCovered.providedMainAdvice) {\n    // Check if the user's last message is about something new\n    const userMessage = messageText.toLowerCase();\n    \n    // If user mentions a new symptom or issue, restart troubleshooting\n    if (containsNewSymptomInfo(userMessage)) {\n      // Extract any new symptoms from the latest message\n      const latestInfo = extractBoilerInfo(messageText);\n      if (latestInfo.symptoms && latestInfo.symptoms.length > 0) {\n        return generateAdvice(); // Generate fresh advice based on updated symptoms\n      }\n    }\n    \n    // If user seems to be asking for different advice or mentions it didn't help\n    if (userMessage.includes('didn\\'t help') || \n        userMessage.includes('not working') || \n        userMessage.includes('something else') || \n        userMessage.includes('else') ||\n        userMessage.includes('other') ||\n        userMessage.includes('different')) {\n      \n      conversationContext.topicsCovered.providedAlternativeAdvice = true;\n      return addEngineerPhrase(\"Let me suggest something different then! Another common fix for this type of issue is to check if your system needs bleeding to remove trapped air. Also, verify that your boiler's pump is running correctly - you might hear it humming when the heating is on. If you're still having trouble, it might be worth checking if any radiator valves are stuck. How does your system sound when it's running? \", 'technical');\n    }\n    \n    // If the user is asking about a specific part or has a follow-up question\n    if (userMessage.length > 0 && userMessage !== 'something else' && userMessage !== 'something els') {\n      // This handles any other follow-up questions by providing relevant information\n      return addEngineerPhrase(\"That's a good question! Based on what you've described with your \" + \n        (conversationContext.manufacturer || 'boiler') + \n        \", I'd recommend checking the specific component you mentioned. If you're still experiencing issues after trying the suggestions, it might be worth having a heating engineer take a look at it. Is there anything specific about your system you'd like me to explain? \", 'technical');\n    }\n    \n    // Default follow-up if we've already provided advice\n    return addEngineerPhrase(\"Did that advice help? Or would you like me to suggest something else? I'm happy to troubleshoot further if you need! \", 'closing');\n  }\n  \n  // Fallback response if nothing else matches\n  return addEngineerPhrase(\"Let me know a bit more about what's happening with your boiler. Any specific symptoms or fault codes?\", 'technical');\n};\n\n// Helper function to check if a message contains new symptom information\nconst containsNewSymptomInfo = (message) => {\n  // Common words/phrases that indicate new symptoms\n  const symptomIndicators = [\n    'noise', 'sound', 'bang', 'click', 'hiss', 'whistle',\n    'leak', 'drip', 'water', 'wet', 'damp',\n    'heat', 'cold', 'hot', 'warm', 'temperature',\n    'pressure', 'gauge', 'bar', 'low', 'high',\n    'flame', 'pilot', 'ignite', 'light', 'spark',\n    'error', 'fault', 'code', 'display', 'flashing',\n    'radiator', 'tap', 'shower', 'boiler', 'thermostat',\n    'frozen', 'ice', 'burst', 'crack'\n  ];\n  \n  const messageLower = message.toLowerCase();\n  return symptomIndicators.some(indicator => messageLower.includes(indicator));\n};\n\n// Helper function to describe symptoms in a natural way\nconst describeSymptoms = (symptoms) => {\n  if (symptoms.length === 0) return \"the issues\";\n  \n  const symptomDescriptions = {\n    noHeat: \"no heating\",\n    noHotWater: \"no hot water\",\n    leaking: \"a leak\",\n    noise: \"unusual noise\",\n    pressure: \"pressure problems\",\n    flame: \"flame failure issues\",\n    lockout: \"frequent lockouts\"\n  };\n  \n  const describedSymptoms = symptoms.map(s => symptomDescriptions[s] || s);\n  \n  if (describedSymptoms.length === 1) return describedSymptoms[0];\n  if (describedSymptoms.length === 2) return `${describedSymptoms[0]} and ${describedSymptoms[1]}`;\n  \n  const lastSymptom = describedSymptoms.pop();\n  return `${describedSymptoms.join(', ')}, and ${lastSymptom}`;\n};\n\n// Function to diagnose boiler issues based on fault codes\nconst diagnoseBoilerIssue = () => {\n  const { manufacturer, model, faultCodes, symptoms } = conversationContext;\n  \n  // Simple diagnosis logic - in a real app, this would be more sophisticated\n  if (faultCodes.length > 0) {\n    const code = faultCodes[0].toUpperCase();\n    \n    if (manufacturer?.toLowerCase().includes('worcester')) {\n      return `I've seen this before with Worcester Bosch boilers! That fault code ${code} typically points to an issue with ${getWorcesterFaultDescription(code)}.  `;\n    } else if (manufacturer?.toLowerCase().includes('vaillant')) {\n      return `With your Vaillant showing fault code ${code}, this is usually telling us there's ${getVaillantFaultDescription(code)}. Don't worry, we can sort this out!  `;\n    } else {\n      return `I recognize that fault code ${code}! It typically indicates ${getGenericFaultDescription(code)}. Let's get this fixed for you. `;\n    }\n  }\n  return \"\";\n};\n\n// Generate specific advice based on fault codes and manufacturer\nconst generateAdvice = () => {\n  const { manufacturer, faultCodes, symptoms } = conversationContext;\n  \n  // If we have a fault code\n  if (faultCodes.length > 0) {\n    const faultCode = faultCodes[0]; // Use the first fault code\n    \n    // Get diagnosis based on fault code\n    const diagnosis = diagnoseBoilerIssue();\n    \n    if (diagnosis) {\n      return addEngineerPhrase(diagnosis + `I'd suggest checking your water pressure first (should be 1-1.5 bar) and making sure all connections are good. If that doesn't help, try a quick power reset by turning your boiler off for about 5 minutes. How does that sound? `, 'technical');\n    }\n    \n    // Generic fault code advice\n    return addEngineerPhrase(`For fault code ${faultCode} on your ${manufacturer}, let's start with the basics: check your water pressure is between 1-1.5 bar and make sure you have power and gas. If everything looks good there, try resetting your boiler by turning it off for 5 minutes. Have you tried any of these steps already? `, 'technical');\n  }\n  \n  // If we don't have a fault code but have symptoms\n  if (symptoms.length > 0) {\n    if (symptoms.includes('noHeat') && !symptoms.includes('noHotWater')) {\n      return addEngineerPhrase(`No heating but hot water works? I see this a lot with ${manufacturer} boilers!  First, let's check your thermostat - is it set to heating mode and calling for heat? Next, have a quick look at your radiator valves - are they open? The diverter valve might be stuck in hot water mode - sometimes a gentle tap can free it up! Is your boiler making any attempt to fire up when you ask for heating? Let me know what you find! `, 'technical');\n    }\n    \n    if (symptoms.includes('noHotWater') && !symptoms.includes('noHeat')) {\n      return addEngineerPhrase(`No hot water from your ${manufacturer}? Don't worry, we can sort this out!  First question - does your boiler try to fire up when you turn on hot water? If it does, we might be looking at a diverter valve issue or a hot water sensor problem. Also worth checking if all your isolation valves are fully open and that your hot water settings haven't been accidentally changed. These are quick fixes most of the time! `, 'technical');\n    }\n    \n    if (symptoms.includes('pressure')) {\n      return addEngineerPhrase(`Pressure problems are super common with ${manufacturer} boilers - nothing to worry about!  If your pressure's too low (under 1 bar), you'll need to top it up using the filling loop. Keep losing pressure? Look for any small leaks, check if the pressure relief valve is releasing, or take a look at the expansion vessel. Pressure too high? Try bleeding your radiators or make sure the filling loop isn't letting water in. Let me know what the pressure gauge is showing and we'll go from there! `, 'technical');\n    }\n    \n    if (symptoms.includes('noise')) {\n      return addEngineerPhrase(`Noisy ${manufacturer} boiler? Let's figure out what it's trying to tell us!  If it's making a kettling or rumbling sound, that's usually limescale on the heat exchanger - a power flush might be just the ticket. Whistling or high-pitched noises? Probably air in the system - bleeding your radiators should help. Banging noises could be water hammer or a pump issue. And gurgling is almost always air that needs bleeding out. What kind of noise are you hearing exactly? `, 'technical');\n    }\n  }\n  \n  // If we have the manufacturer but limited other info\n  return addEngineerPhrase(`Based on what you've told me about your ${manufacturer} boiler, I'd recommend starting with the basics: check the power supply, make sure the gas is on, verify the water pressure is between 1-1.5 bar, and ensure all isolation valves are open. Also check that any external controls like room thermostats or timers are set correctly. Can you tell me exactly what you see happening when the problem occurs?`, 'technical');\n};\n\nexport const engineerChatService = {\n  // Process a new message and generate a response\n  async processMessage(history) {\n    // Add a small delay to simulate network request\n    await new Promise(resolve => setTimeout(resolve, 600 + Math.random() * 400));\n    \n    // Get the last user message\n    const lastUserMessage = history[history.length - 1].text;\n    \n    // If this is a brand new conversation, reset context\n    if (history.length <= 1) {\n      conversationContext.reset();\n    }\n    \n    // Store complete conversation history for context\n    conversationContext.completeHistory = [...history];\n    \n    // Check previous messages for any missed manufacturer or model information\n    if (history.length > 1 && (!conversationContext.manufacturer || !conversationContext.model)) {\n      history.filter(msg => msg.sender === 'user').forEach(msg => {\n        const previousInfo = extractBoilerInfo(msg.text);\n        if (previousInfo.manufacturer && !conversationContext.manufacturer) {\n          conversationContext.manufacturer = previousInfo.manufacturer;\n          conversationContext.topicsCovered.askedAboutManufacturer = true;\n        }\n        if (previousInfo.model && !conversationContext.model) {\n          conversationContext.model = previousInfo.model;\n          conversationContext.topicsCovered.askedAboutModel = true;\n        }\n      });\n    }\n    \n    // Generate engineer response based on message and history\n    const response = generateResponse(lastUserMessage, history);\n    \n    // Debug output (only in development mode)\n    if (import.meta.env.DEV) {\n      console.log('Current conversation context:', {\n        manufacturer: conversationContext.manufacturer,\n        model: conversationContext.model,\n        stage: conversationContext.conversationStage,\n        messageCount: conversationContext.messageCount\n      });\n    }\n    \n    return response;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/utils/systemSchemaLoader.js","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":28,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":28,"endColumn":20,"suggestions":[{"fix":{"range":[747,800],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":47,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":47,"endColumn":18,"suggestions":[{"fix":{"range":[1338,1391],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * System Schema Loader\n * \n * Loads and parses the structured heating system component schema\n * Browser-compatible version that uses pre-processed schema data\n */\nimport yaml from 'js-yaml';\n\n// Cache for the parsed schema\nlet systemSchemaCache = null;\n\n/**\n * Extract and parse the structured system schema from LLMPROMPT.md\n * @returns {Object} The parsed system schema with all component data\n */\nfunction loadSystemSchema() {\n  // Return cached version if available\n  if (systemSchemaCache) {\n    return systemSchemaCache;\n  }\n\n  try {\n    // Instead of reading from file system (which doesn't work in browser),\n    // we use a pre-processed schema\n    const schemaContent = getPreProcessedSchema();\n    \n    if (!schemaContent) {\n      console.error('Failed to load pre-processed schema');\n      return null;\n    }\n    \n    // Parse the schema content (combining direct YAML and code blocks)\n    const yamlContent = schemaContent\n      // Remove YAML metadata at the top\n      .replace(/^# version:.*\\n# last_modified:.*\\n/m, '')\n      // Extract YAML from code blocks (```yaml...```)\n      .replace(/```(?:yaml)?\\n([\\s\\S]*?)```/g, '$1');\n    \n    // Parse the combined YAML\n    const schema = yaml.load(yamlContent);\n    \n    // Cache the result\n    systemSchemaCache = schema;\n    \n    return schema;\n  } catch (error) {\n    console.error('Error loading system schema:', error);\n    return null;\n  }\n}\n\n/**\n * Get system-specific component information based on heating system type\n * @param {string} systemType - 'combi', 'system', 'heat-only'\n * @param {string} componentName - Optional component name to filter\n * @returns {Array|Object} Components for the specified system type\n */\nfunction getSystemComponents(systemType, componentName = null) {\n  const schema = loadSystemSchema();\n  \n  if (!schema) {\n    return null;\n  }\n  \n  // Convert systemType to the format used in the schema\n  const schemaKey = systemType\n    .toLowerCase()\n    .replace(/\\s+/g, '_')\n    .replace('-', '_');\n  \n  // Get components for the specified system type\n  const systemData = schema[schemaKey];\n  \n  if (!systemData || !systemData.components) {\n    return null;\n  }\n  \n  // If component name is specified, return just that component\n  if (componentName) {\n    return systemData.components.find(\n      component => \n        component.component_name.toLowerCase() === componentName.toLowerCase() ||\n        (component.known_aliases && component.known_aliases.some(\n          alias => alias.toLowerCase() === componentName.toLowerCase()\n        ))\n    );\n  }\n  \n  return systemData.components;\n}\n\n/**\n * Find potential components that might be related to specified symptoms\n * @param {string} systemType - 'combi', 'system', 'heat-only'\n * @param {Array} symptoms - Array of symptom descriptions\n * @returns {Array} Components that might be related to the symptoms\n */\nfunction findComponentsBySymptoms(systemType, symptoms) {\n  const components = getSystemComponents(systemType);\n  \n  if (!components) {\n    return [];\n  }\n  \n  // Convert symptoms to lowercase for case-insensitive matching\n  const lowerSymptoms = symptoms.map(s => s.toLowerCase());\n  \n  // Find components with matching observable symptoms\n  return components.filter(component => {\n    // Check if component has observable symptoms\n    if (!component.observable_symptoms) {\n      return false;\n    }\n    \n    // Check each symptom type (error_codes, noises, etc.)\n    return Object.values(component.observable_symptoms).some(symptomList => {\n      if (typeof symptomList === 'string') {\n        // For string symptom descriptions, check if any of our symptoms are contained\n        return lowerSymptoms.some(s => symptomList.toLowerCase().includes(s));\n      } else if (Array.isArray(symptomList)) {\n        // For arrays, check if any of our symptoms match any in the list\n        return lowerSymptoms.some(s => \n          symptomList.some(listItem => listItem.toLowerCase().includes(s))\n        );\n      }\n      return false;\n    });\n  });\n}\n\n/**\n * Returns the pre-processed schema content\n * This replaces file system operations that don't work in browsers\n * \n * @returns {string} The pre-processed schema content\n */\nfunction getPreProcessedSchema() {\n  // This is a simplified version of the schema for demonstration\n  // In production, this would be a complete schema extracted at build time\n  return `\ncombi_boiler:\n  components:\n    - component_name: \"Heat Exchanger\"\n      known_aliases: [\"main heat exchanger\", \"primary heat exchanger\"]\n      purpose: \"Transfers heat from gas combustion to central heating water.\"\n      interacts_with: [\"Fan\", \"Gas valve\", \"Pump\", \"Flow sensor\"]\n      typical_faults:\n        - scaling\n        - blockage\n        - leak\n        - thermal_crack\n      observable_symptoms:\n        noises: [\"kettling\", \"rumbling\", \"whistling\"]\n        temp_profile: \"Inconsistent heating; hot spots\"\n      quick_tests:\n        - \"Check for consistent temperature across exchanger surface.\"\n        - \"Inspect for signs of leaks or corrosion.\"\n      decision_rules:\n        - if: \"Noise increases with temperature AND pressure drops\"\n          then: \"heat_exchanger.scaling\"\n\nheat_only_boiler:\n  components:\n    - component_name: \"Feed & Expansion Tank\"\n      known_aliases: [\"F&E tank\", \"header tank\"]\n      purpose: \"Provides static head and makes up water in openvented systems.\"\n      interacts_with: [\"Vent pipe\", \"Gravity return\"]\n      typical_faults:\n        - ball_valve_seized\n        - tank_sludge\n      observable_symptoms:\n        noises: [\"gurgling at high points\"]\n        temp_profile: \"Low pressure at boiler; air ingress\"\n      quick_tests:\n        - \"Lift ball valve; verify fresh water enters freely.\"\n      decision_rules:\n        - if: \"Air in radiators daily AND tank empty\"\n          then: \"feed_expansion_tank.ball_valve_seized\"\n    - component_name: \"Gravity Primary Circuit\"\n      known_aliases: [\"gravity hot water circuit\"]\n      purpose: \"Relies on thermosyphon to circulate between boiler and cylinder.\"\n      interacts_with: [\"Cylinder coil\", \"Vent pipe\"]\n      typical_faults:\n        - blocked_cold_feed\n        - incorrect_pipe_fall\n      observable_symptoms:\n        temp_profile: \"Slow cylinder heating; boiler cycles rapidly\"\n      quick_tests:\n        - \"Feel flow and return; <10 C delta after 30 min suggests blockage.\"\n      decision_rules:\n        - if: \"Cylinder temp <40 C after 1 h gravity heat\"\n          then: \"gravity_primary_circuit.blocked_cold_feed\"\n\nsystem_boiler:\n  components:\n    - component_name: \"Diverter Valve\"\n      known_aliases: [\"3-way valve\", \"DHW priority valve\"]\n      purpose: \"Directs flow between heating and hot water circuits.\"\n      interacts_with: [\"Pump\", \"Expansion vessel\", \"Hot water cylinder\"]\n      typical_faults:\n        - stuck_in_midposition\n        - actuator_failure\n        - valve_blockage\n      observable_symptoms:\n        noises: [\"humming\", \"buzzing\"]\n        temp_profile: \"Hot water but no heating, or vice versa\"\n      quick_tests:\n        - \"Listen for motor actuation when switching modes.\"\n        - \"Check resistance of valve motor.\"\n      decision_rules:\n        - if: \"Hot water OR heating but never both\"\n          then: \"diverter_valve.stuck\"\n`;  \n}\n\nexport const systemSchema = {\n  loadSystemSchema,\n  getSystemComponents,\n  findComponentsBySymptoms\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/markburrows/CascadeProjects/bigbrain_website/bigbrain_recovered/src/utils/useDebounce.js","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":45,"fix":{"range":[188,188],"text":"\n"}},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":20,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":26,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":19}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/**\n * Custom hook for debouncing values\n * Used for search inputs and other frequently changing values\n * to reduce unnecessary operations\n */\nimport { useState, useEffect } from 'react';\nimport { UI } from './constants';\n\n/**\n * useDebounce hook for delaying state updates\n * @param {any} value - The value to debounce\n * @param {number} delay - Delay time in milliseconds, defaults to search debounce\n * @returns {any} The debounced value\n */\nexport function useDebounce(value, delay = UI.DEBOUNCE.SEARCH) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    // Set debouncedValue to value after the specified delay\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    // Cancel the timeout if value changes or unmounts\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n","usedDeprecatedRules":[]}]
