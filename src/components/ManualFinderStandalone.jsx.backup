import React, { useState, useEffect, useRef, useCallback } from 'react';
import { supabase } from '../supabaseClient';
import { createPortal } from 'react-dom';
import { FixedSizeList as List } from 'react-window';
import { getCachedData, setCachedData } from '../utils/cacheUtils';
import { useDebounce } from '../utils/useDebounce';
import { UI, CACHE, TIME } from '../utils/constants';

// Toast notification display time
const TOAST_DISPLAY_TIME = 3 * TIME.SECOND;
const TOAST_ANIMATION_TIME = 300; // milliseconds

// Toast notification component
const Toast = ({ message, type = 'success', onClose }) => {
  const [visible, setVisible] = useState(true);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setVisible(false);
      setTimeout(onClose, TOAST_ANIMATION_TIME); // Allow exit animation to play
    }, TOAST_DISPLAY_TIME);
    
    return () => clearTimeout(timer);
  }, [onClose]);
  
  return createPortal(
    <div 
      className={`fixed bottom-5 right-5 flex items-center gap-2 py-3 px-4 rounded-lg shadow-lg transition-opacity duration-300 ${visible ? 'opacity-100' : 'opacity-0'} ${
        type === 'success' ? 'bg-green-50 text-green-800 border border-green-200' : 
        type === 'error' ? 'bg-red-50 text-red-800 border border-red-200' : 
        'bg-blue-50 text-blue-800 border border-blue-200'
      }`}
    >
      <span className="text-xl">
        {type === 'success' ? 'âœ“' : type === 'error' ? 'âœ•' : 'â„¹'}
      </span>
      <p className="body-md">{message}</p>
      <button 
        onClick={() => {
          setVisible(false);
          setTimeout(onClose, TOAST_ANIMATION_TIME);
        }}
        className="ml-4 text-current opacity-70 hover:opacity-100"
        aria-label="Close notification"
      >
        Ã—
      </button>
    </div>,
    document.body
  );
};

// Row component for virtualized manufacturer list
const ManufacturerRow = ({ index, style, data }) => {
  const { items, selectedItem, onSelect } = data;
  const manufacturer = items[index];
  
  return (
    <button
      style={style}
      className={`block w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 ${selectedItem === manufacturer ? 'bg-blue-100 dark:bg-blue-900' : ''}`}
      onClick={() => onSelect(manufacturer)}
    >
      {manufacturer}
    </button>
  );
};

// Row component for virtualized manual list
const ManualRow = ({ index, style, data }) => {
  const { manuals, downloading, downloadingId, handleDownload } = data;
  const manual = manuals[index];
  
  return (
    <div style={{
      ...style,
      display: 'flex',
      padding: '8px',
    }}>
      <div className="bg-white dark:bg-[#2C2C2E] border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden shadow-sm hover:shadow-md transition-shadow w-full">
        <div className="p-4">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">{manual.make}</h3>
          <h4 className="text-md font-medium text-gray-800 dark:text-gray-200 mt-1">{manual.model}</h4>
          
          <div className="mt-3 flex flex-wrap gap-2">
            {manual.fuel_type && (
              <span className="px-2 py-1 text-xs rounded-full bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200">
                {manual.fuel_type}
              </span>
            )}
            {manual.boiler_type && (
              <span className="px-2 py-1 text-xs rounded-full bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200">
                {manual.boiler_type}
              </span>
            )}
          </div>
          
          <div className="mt-4">
            <button 
              onClick={() => handleDownload(manual.id)}
              disabled={downloading && downloadingId === manual.id}
              className={`w-full flex justify-center items-center px-4 py-2 rounded-md ${downloading && downloadingId === manual.id
                ? 'bg-gray-300 dark:bg-gray-700 cursor-not-allowed'
                : 'bg-blue-600 hover:bg-blue-700 text-white'}`}
            >
              {downloading && downloadingId === manual.id ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-white mr-2"></div>
                  Downloading...
                </>
              ) : (
                'Download Manual'
              )}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

/**
 * Manual Finder Component
 * Allows users to search and download boiler manuals
 */
/**
 * Manual Finder Component
 * Allows users to search and download boiler manuals
 */
export function ManualFinderStandalone() {
    // State declarations
  const [query, setQuery] = useState('');
  const [manuals, setManuals] = useState([]);
  const [downloading, setDownloading] = useState(false);
  const [downloadingId, setDownloadingId] = useState(null);
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const [isManufacturerDropdownOpen, setIsManufacturerDropdownOpen] = useState(false);
  const [manufacturers, setManufacturers] = useState([]);
  const [selectedManufacturer, setSelectedManufacturer] = useState('');
  const [manufacturerSearch, setManufacturerSearch] = useState('');
  const [toast, setToast] = useState(null);
  
  // Pagination state
  const [page, setPage] = useState(0);
  const [hasMore, setHasMore] = useState(true);
  const [loadingMore, setLoadingMore] = useState(false);
  const PAGE_SIZE = UI.LIST.PAGE_SIZE;
  
  // Apply debounce to search queries
  const debouncedQuery = useDebounce(query, UI.DEBOUNCE.SEARCH);
  const debouncedManufacturerSearch = useDebounce(manufacturerSearch, UI.DEBOUNCE.SEARCH / 2); // Faster for manufacturer search

  // Refs for handling outside clicks and focus
  const manufacturerRef = useRef(null);
  const searchRef = useRef(null);
  const dropdownRef = useRef(null);

  // Handle outside clicks for dropdown
  useEffect(() => {
    function handleClickOutside(event) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsManufacturerDropdownOpen(false);
      }
    }
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [dropdownRef]);

  // Fetch all unique manufacturers from multiple sources with caching
  useEffect(() => {
    const fetchAllManufacturers = async () => {
      try {
        // Try to get manufacturers from cache first
        const CACHE_KEY = 'all_manufacturers';
        const CACHE_TTL = CACHE.MANUFACTURER_TTL; // 24 hours
        
        const cachedManufacturers = getCachedData(CACHE_KEY, { 
          useLocalStorage: true, 
          ttl: CACHE_TTL 
        });
        
        if (cachedManufacturers) {
          console.log('Using cached manufacturers data');
          setManufacturers(cachedManufacturers);
          setFilteredManufacturers(cachedManufacturers);
          return;
        }

        console.log('Fetching all manufacturers from multiple sources...');
        const uniqueManufacturers = new Set();

        // Try different approaches to maximize coverage
        
        // 1. Paginated query of boilers table
        console.log('Fetching from boilers table...');
        let page = 0;
        let hasMore = true;
        const pageSize = UI.LIST.PAGE_SIZE * 5; // Larger page size for initial load
        
        while (hasMore) {
          const { data, error } = await supabase
            .from('boilers')
            .select('make')
            .order('make')
            .range(page * pageSize, (page + 1) * pageSize - 1);
          
          if (error) {
            console.error('Error fetching boilers:', error);
            break;
          }
          
          if (!data || data.length === 0) break;
          
          data.forEach(item => {
            if (item.make && item.make.trim() !== '') {
              uniqueManufacturers.add(item.make.trim());
            }
          });
          
          hasMore = data.length === pageSize;
          page++;
        }
        
        console.log(`Found ${uniqueManufacturers.size} manufacturers from database`);

        // 2. Fetch from storage bucket to find any additional manufacturers
        // Common manufacturers list for comprehensive coverage
        const commonManufacturers = [
          'Vaillant', 'Worcester Bosch', 'Baxi', 'Ideal', 'Glow-worm', 
          'Viessmann', 'Ariston', 'Potterton', 'Ferroli', 'Alpha', 
          'Vokera', 'Ravenheat', 'Intergas', 'Gledhill', 'Biasi', 'Main'
        ];
        
        // Ensure common manufacturers are included
        commonManufacturers.forEach(m => uniqueManufacturers.add(m));

        // Function to recursively fetch from storage buckets
        const fetchFromBucket = async (prefix = '', fetchedPaths = new Set()) => {
          // Skip if already fetched to avoid infinite recursion
          if (fetchedPaths.has(prefix)) return;
          fetchedPaths.add(prefix);
          
          // List items in current path
          const { data, error } = await supabase.storage
            .from('boiler-manuals')
            .list(prefix, {
              limit: 1000, // Maximum allowed by Supabase storage API
              offset: 0,
              sortBy: { column: 'name', order: 'asc' }
            });

          if (error) {
            console.error(`Error listing bucket at ${prefix}:`, error);
            return;
          }

          if (!data || data.length === 0) return;

          // Process folders and files
          const subfolders = [];
          
          for (const item of data) {
            const fullPath = prefix ? `${prefix}/${item.name}` : item.name;

            // Check if this is a folder (directories in Supabase storage have id=null)
            if (item.id === null) {
              // This is a folder - consider as a manufacturer
              uniqueManufacturers.add(item.name);
              subfolders.push(fullPath);
            } else if (item.name.endsWith('.pdf') && !prefix) {
              // If it's a top-level PDF, try to extract manufacturer name
              const possibleManufacturer = item.name.split('_')[0];
              if (possibleManufacturer) {
                uniqueManufacturers.add(possibleManufacturer);
              }
            }
          }

          // Check subfolders recursively
          for (const subfolder of subfolders) {
            await fetchFromBucket(subfolder, fetchedPaths);
          }
        };

        // Fetch from storage buckets
        await fetchFromBucket();
        console.log(`After bucket search: ${uniqueManufacturers.size} manufacturers found`);
        
        // 3. Query boiler_manuals
        const { data: manualData, error: manualError } = await supabase
          .from('boiler_manuals')
          .select('manufacturer');
          
        if (!manualError && manualData) {
          manualData.forEach(manual => {
            if (manual.manufacturer && manual.manufacturer.trim() !== '') {
              uniqueManufacturers.add(manual.manufacturer.trim());
            }
          });
        } else if (manualError) {
          console.error('Error fetching boiler manuals:', manualError);
        }

        // 4. Direct query of manual records
        const { data: manualRecords, error: recordsError } = await supabase
          .from('manual_records')
          .select('manufacturer')
          .order('manufacturer');
          
        if (!recordsError && manualRecords) {
          manualRecords.forEach(record => {
            if (record.manufacturer && record.manufacturer.trim() !== '') {
              uniqueManufacturers.add(record.manufacturer.trim());
            }
          });
        } else if (recordsError) {
          console.error('Error fetching manual records:', recordsError);
        }

        // Convert set to array, filter out empty values, and sort
        const allManufacturers = Array.from(uniqueManufacturers)
          .filter(m => m && m.trim() !== '')
          .sort((a, b) => a.localeCompare(b));

        // Update state
        setManufacturers(allManufacturers);
        setFilteredManufacturers(allManufacturers);
        
        // Store in cache for future use
        setCachedData(CACHE_KEY, allManufacturers, { useLocalStorage: true });
        
        console.log(`Found ${allManufacturers.length} total unique manufacturers (cached for 24 hours)`);
      } catch (err) {
        console.error('Error in manufacturers fetch:', err);
        setError('Failed to load manufacturers. Please try again.');
      }
    };

    fetchAllManufacturers();
  }, []);

  // Special function to fetch all Ideal boilers using multiple strategies
  const fetchAllIdealBoilers = useCallback(async () => {
    try {
      // Strategy 1: Alphabetical ranges to avoid Supabase pagination limits
      const alphabet = 'abcdefghijklmnopqrstuvwxyz0123456789';
      const modelResults = new Map();
      
      // First collect data using prefix searches (A*, B*, C*, etc.)
      console.log('Using alphabetical fetching strategy for Ideal boilers');
      
      // Create prefixes (lowercase for case-insensitive matching)
      for (let char of alphabet) {
        // Get all models starting with this letter
        const { data, error } = await supabase
          .from('boilers')
          .select('*')
          .eq('make', 'Ideal')
          .ilike('model', `${char}%`);
        
        if (error) {
          console.error(`Error fetching Ideal models starting with ${char}:`, error);
          continue;
        }
        
        if (data && data.length > 0) {
          console.log(`Found ${data.length} Ideal models starting with '${char}'`);
          
          // Add to map using ID as key to prevent duplicates
          data.forEach(model => {
            modelResults.set(model.id, model);
          });
        }
      }
      
      // Strategy 2: Number ranges for numeric models
      const numberRanges = ['0-9', '10-99', '100-999'];
      for (let range of numberRanges) {
        let min, max;
        if (range === '0-9') {
          min = 0;
          max = 9;
        } else if (range === '10-99') {
          min = 10;
          max = 99;
        } else {
          min = 100;
          max = 999;
        }
        
        // This approach will find models that are numbers or start with numbers
        for (let i = min; i <= max; i++) {
          const { data, error } = await supabase
            .from('boilers')
            .select('*')
            .eq('make', 'Ideal')
            .ilike('model', `${i}%`);
          
          if (error) {
            console.error(`Error fetching Ideal models with number ${i}:`, error);
            continue;
          }
          
          if (data && data.length > 0) {
            // Add to map using ID as key
            data.forEach(model => {
              modelResults.set(model.id, model);
            });
            console.log(`Found ${data.length} Ideal models containing '${i}'`);
          }
        }
      }
      
      // Convert map to array and sort
      const allResults = Array.from(modelResults.values());
      allResults.sort((a, b) => a.model.localeCompare(b.model));
      
      console.log(`Total Ideal manuals found with all strategies: ${allResults.length}`);
      setManuals(allResults);
    } catch (error) {
      console.error('Error in specialized Ideal boiler fetching:', error);
      setError('Error loading all Ideal boilers. Please try again.');
    } finally {
      setLoading(false);
    }
  }, []);

  // Handle search input changes and initiate search
  const handleSearch = useCallback(async () => {
    setError('');  
    setLoading(true);
    setManuals([]); // Reset results for new search
    setPage(0);     // Reset to first page
    setHasMore(true); // Reset pagination state
    
    // Ensure we have a valid search query
    if (!debouncedQuery.trim() && !selectedManufacturer) {
      setManuals([]);
      setLoading(false);
      setHasMore(false);
      return;
    }

    // Special handling for Ideal boilers - we know there are 300+
    if (selectedManufacturer === 'Ideal' && !debouncedQuery) {
      console.log('Using specialized fetch strategy for Ideal boilers');
      await fetchAllIdealBoilers();
      return;
    }
    
    // Regular fetching strategy for other manufacturers or when searching
    // Set up pagination parameters
    let allResults = [];
    let hasMore = true;
    let page = 0;
    const pageSize = PAGE_SIZE; // Use PAGE_SIZE for pagination
    
    console.log(`Fetching manuals for ${selectedManufacturer || 'any manufacturer'} and model containing "${debouncedQuery || ''}"`);      
    
    try {
      // Fetch all pages of results
      while (hasMore) {
        // Build query with pagination
        let queryBuilder = supabase
          .from('boilers')
          .select('*')
          .range(page * pageSize, (page + 1) * pageSize - 1);
        
        if (debouncedQuery) {
          queryBuilder = queryBuilder.ilike('model', `%${debouncedQuery}%`);
        }
        
        if (selectedManufacturer) {
          queryBuilder = queryBuilder.eq('make', selectedManufacturer);
        }

        // Execute query for this page
        const { data, error, count } = await queryBuilder;

        if (error) {
          console.error(`Error fetching page ${page}:`, error);
          throw error;
        }

        // Add current page results to our collection
        if (data && data.length > 0) {
      
      if (error) {
        console.error(`Error fetching Ideal models starting with ${char}:`, error);
        continue;

  // Fetch manuals based on query and selected manufacturer with proper pagination
  useEffect(() => {
    // Skip initial empty search on component mount
    if (debouncedQuery === '' && !selectedManufacturer) return;  
    handleSearch();
  }, [debouncedQuery, selectedManufacturer, handleSearch]);


    try {
      // Strategy 1: Alphabetical ranges to avoid Supabase pagination limits
      const alphabet = 'abcdefghijklmnopqrstuvwxyz0123456789';
      const modelResults = new Map();
      
      // First collect data using prefix searches (A*, B*, C*, etc.)
      console.log('Using alphabetical fetching strategy for Ideal boilers');
      
      // Create prefixes (lowercase for case-insensitive matching)
      for (let char of alphabet) {
        // Get all models starting with this letter
        const { data, error } = await supabase
          .from('boilers')
          .select('*')
          .eq('make', 'Ideal')
          .ilike('model', `${char}%`);
        
        if (error) {
          console.error(`Error fetching Ideal models starting with ${char}:`, error);
          continue;
        }
        
        if (data && data.length > 0) {
          console.log(`Found ${data.length} Ideal models starting with '${char}'`);
          
          // Add to map using ID as key to prevent duplicates
          data.forEach(model => {
            modelResults.set(model.id, model);
          });
        }
      }
      
      // Strategy 2: Number ranges for numeric models
      const numberRanges = ['0-9', '10-99', '100-999'];
      for (let range of numberRanges) {
        let min, max;
        if (range === '0-9') {
          min = 0;
          max = 9;
        } else if (range === '10-99') {
          min = 10;
          max = 99;
        } else {
          min = 100;
          max = 999;
        }
        
        // This approach will find models that are numbers or start with numbers
        for (let i = min; i <= max; i++) {
          const { data, error } = await supabase
            .from('boilers')
            .select('*')
            .eq('make', 'Ideal')
            .ilike('model', `${i}%`);
          
          if (error) {
            console.error(`Error fetching Ideal models with number ${i}:`, error);
            continue;
          }
          
          if (data && data.length > 0) {
            // Add to map using ID as key
            data.forEach(model => {
              modelResults.set(model.id, model);
            });
            console.log(`Found ${data.length} Ideal models containing '${i}'`);
          }
        }
      }
      
      // Convert map to array and sort
      const allResults = Array.from(modelResults.values());
      allResults.sort((a, b) => a.model.localeCompare(b.model));
      
      console.log(`Total Ideal manuals found with all strategies: ${allResults.length}`);
      setManuals(allResults);
    } catch (error) {
      console.error('Error in specialized Ideal boiler fetching:', error);
      setError('Error loading all Ideal boilers. Please try again.');
    } finally {
      setLoading(false);
    }
  }, []);


      
      // Determine if we need to fetch another page
      hasMore = data && data.length === pageSize;
      page++;
      
      // Safety check - don't fetch more than 10 pages (10,000 results)
      if (page > 10) {
        console.warn('Reached maximum page limit of 10 pages');
        hasMore = false;
      }
    }
    
    // Sort results by model name for better UX
    allResults.sort((a, b) => a.model.localeCompare(b.model));
    
    console.log(`Total manuals found: ${allResults.length}`);
    setManuals(allResults);
  }, [debouncedQuery, selectedManufacturer]);

  // Filter manufacturers based on debounced search
  const filteredManufacturersList = useMemo(() => {
    console.log('Computing filtered manufacturers list');
    if (debouncedManufacturerSearch === '') {
      return manufacturers;
    } else {
      return manufacturers.filter(m => 
        m.toLowerCase().includes(debouncedManufacturerSearch.toLowerCase())
      );
    }
  }, [manufacturers, debouncedManufacturerSearch]);

  useEffect(() => {
    setFilteredManufacturers(filteredManufacturersList);
  }, [filteredManufacturersList]);

  // Load more function for infinite scrolling
  const loadMoreManuals = useCallback(async () => {
    if (!hasMore || loadingMore) return;
    
    try {
      setLoadingMore(true);
      const nextPage = page + 1;
      
      console.log(`Loading more manuals (page: ${nextPage}, limit: ${PAGE_SIZE})`);
      
      // Build query with proper pagination
      let queryBuilder = supabase
        .from('boilers')
        .select('*')
        .range(nextPage * PAGE_SIZE, (nextPage + 1) * PAGE_SIZE - 1);
      
      if (debouncedQuery) {
        queryBuilder = queryBuilder.ilike('model', `%${debouncedQuery}%`);
      }
      
      if (selectedManufacturer) {
        queryBuilder = queryBuilder.eq('make', selectedManufacturer);
      }

      const { data, error } = await queryBuilder;

      if (error) {
        console.error(`Error fetching page ${nextPage}:`, error);
        throw error;
      }

      if (data && data.length > 0) {
        console.log(`Loaded ${data.length} more manuals`);
        setManuals(prevManuals => [...prevManuals, ...data]);
        setPage(nextPage);
        setHasMore(data.length === PAGE_SIZE);
      } else {
        console.log('No more manuals to load');
        setHasMore(false);
      }
    } catch (err) {
      console.error('Error loading more manuals:', err);
      setError('Failed to load more manuals. Please try again.');
    } finally {
      setLoadingMore(false);
    }
  }, [debouncedQuery, selectedManufacturer, page, hasMore, loadingMore, PAGE_SIZE]);

  // Function to handle downloads using the direct URL from the database
  const handleDownload = async (id) => {
    setDownloadingId(id);
    setDownloading(true);
    
    try {
      const manual = manuals.find(m => m.id === id);
      if (!manual) throw new Error('Manual not found in local list');
      
      const { make, model, pdf_url } = manual;
      console.log(`Attempting download for ${make || 'N/A'} - ${model || 'N/A'}. Stored pdf_url: ${pdf_url || 'N/A'}`);

      // Verify we have a URL
      if (!pdf_url) {
        throw new Error('Manual record does not have a PDF URL');
      }
      
      console.log('Using direct URL from database:', pdf_url);
      
      // Create sanitized filename for download
      const sanitizeFilename = (name) => 
        (name || '').replace(/[^a-zA-Z0-9_.-]/g, '_').replace(/_{2,}/g, '_') || 'file';
      const downloadFilename = `${sanitizeFilename(make || 'manual')}_${sanitizeFilename(model || 'file')}.pdf`;
      
      // Direct approach: Use the URL directly from the database to download
      // We'll fetch it first to make sure it exists
      console.log('Fetching PDF to verify it exists:', pdf_url);
      
      try {
        const response = await fetch(pdf_url, {
          method: 'HEAD',
          cache: 'no-cache',
        });
        
        if (!response.ok) {
          console.error(`PDF URL returned ${response.status}: ${response.statusText}`);
          throw new Error(`PDF file not available (${response.status})`);
        }
        
        console.log('PDF exists, initiating download');
        
        // PDF exists, proceed with download
        const a = document.createElement('a');
        a.href = pdf_url;
        a.download = downloadFilename;
        a.target = '_blank'; // Open in new tab as fallback
        a.rel = 'noopener noreferrer';
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        
        // Remove the element after a delay
        setTimeout(() => {
          if (document.body.contains(a)) {
            document.body.removeChild(a);
          }
        }, 100);
        
        setToast({
          message: `Successfully initiated download for ${model || 'manual'}`,
          type: 'success'
        });
      } catch (fetchError) {
        console.error('Error fetching PDF:', fetchError);
        
        // Try alternative approach - open in new tab
        console.log('Trying alternative approach - opening PDF in new tab');
        window.open(pdf_url, '_blank', 'noopener,noreferrer');
        
        setToast({
          message: `Opening PDF in new tab for ${model || 'manual'}`,
          type: 'info'
        });
      }
      
    } catch (error) {
      console.error('Error in handleDownload:', error);
      setError(`Failed to download manual: ${error.message}`);
      setToast({ 
        message: `Failed to download manual. ${error.message.length > 100 ? error.message.substring(0,100)+'...' : error.message}`,
        type: 'error' 
      });
    } finally {
      setDownloadingId(null);
      setDownloading(false);
    }
  };

  // Render component
  return (
    <div className="min-h-[80vh] flex flex-col items-center justify-start py-8 px-4 bg-gray-50">
      {/* Toast notification */}
      {toast && (
        <Toast
          message={toast.message}
          type={toast.type}
          onClose={() => setToast(null)}
        />
      )}
      
      <h1 className="heading-xl text-center mb-6 mt-2 text-slate-800">Find a ðŸ§  Boiler Brain Manual</h1>
      
      <div className="content-card">
        {/* Search and filter section */}
        <div className="bg-white rounded-xl shadow-md p-6 mb-8">
          {/* Manufacturer Search Section */}
          <div className="flex flex-col mb-6">
            <label htmlFor="manufacturerSearch" className="heading-sm text-gray-800 mb-2">Manufacturer</label>
            <div className="relative" ref={dropdownRef}>
              <div className="relative flex">
                {/* Manufacturer Search Input */}
                <input
                  id="manufacturerSearch"
                  type="text"
                  className="search-input body-md text-gray-900 pr-10 w-full"
                  placeholder="Search manufacturer..."
                  value={manufacturerSearch}
                  onChange={e => {
                    setManufacturerSearch(e.target.value);
                    setIsManufacturerDropdownOpen(true);
                  }}
                  onClick={() => setIsManufacturerDropdownOpen(true)}
                  ref={manufacturerRef}
                  aria-label="Search for boiler manufacturer"
                  aria-expanded={isManufacturerDropdownOpen}
                  aria-controls="manufacturer-dropdown"
                />
                {/* Dropdown toggle button */}
                <button 
                  type="button"
                  className="absolute right-0 top-0 h-full px-3 text-gray-500 hover:text-gray-700 focus:outline-none"
                  onClick={() => setIsManufacturerDropdownOpen(!isManufacturerDropdownOpen)}
                  aria-label="Toggle manufacturer dropdown"
                >
                  {isManufacturerDropdownOpen ? 'â–²' : 'â–¼'}
                </button>
              </div>
              
              {/* Selected Manufacturer Display */}
              {selectedManufacturer && (
                <div className="mt-2 px-3 py-2 bg-gray-100 rounded-lg flex items-center justify-between body-md">
                  <span className="text-gray-800">{selectedManufacturer}</span>
                  <button 
                    onClick={() => {
                      setSelectedManufacturer('');
                      setManufacturerSearch('');
                    }}
                    className="text-gray-500 hover:text-gray-700 focus:outline-none ml-2"
                    aria-label="Clear manufacturer selection"
                  >
                    Ã—
                  </button>
                </div>
              )}
              
              {/* Dropdown Options */}
              {isManufacturerDropdownOpen && (
                <div 
                  id="manufacturer-dropdown"
                  className="absolute w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg z-10 overflow-y-auto"
                  style={{ maxHeight: '400px', overflowY: 'auto', overscrollBehavior: 'contain' }}
                >
                  <div className="py-1">
                    <button
                      className={`w-full text-left px-4 py-3 body-md min-h-[44px] hover:bg-gray-100 ${!selectedManufacturer ? 'bg-slate-800 text-white' : 'text-gray-800'}`}
                      onClick={() => {
                        setSelectedManufacturer('');
                        setManufacturerSearch('');
                        setIsManufacturerDropdownOpen(false);
                      }}
                    >
                      All Manufacturers
                    </button>
                    
                    {filteredManufacturers
                      .map(manufacturer => {
                        // Highlight the matching text if there's a search query
                        const highlightMatch = () => {
                          if (!manufacturerSearch) return manufacturer;
                          
                          const lowerManufacturer = manufacturer.toLowerCase();
                          const lowerSearch = manufacturerSearch.toLowerCase();
                          const index = lowerManufacturer.indexOf(lowerSearch);
                          
                          if (index === -1) return manufacturer;
                          
                          return (
                            <>
                              {manufacturer.substring(0, index)}
                              <span className="bg-primary-100 text-primary-800 font-medium">
                                {manufacturer.substring(index, index + manufacturerSearch.length)}
                              </span>
                              {manufacturer.substring(index + manufacturerSearch.length)}
                            </>
                          );
                        };
                        
                        return (
                          <button
                            key={manufacturer}
                            className={`w-full text-left px-4 py-3 body-md min-h-[44px] hover:bg-gray-100 ${selectedManufacturer === manufacturer ? 'bg-slate-800 text-white' : 'text-gray-800'}`}
                            onClick={() => {
                              setSelectedManufacturer(manufacturer);
                              setManufacturerSearch('');
                              setIsManufacturerDropdownOpen(false);
                            }}
                          >
                            {highlightMatch()}
                          </button>
                        );
                      })}
                      
                    {/* Display message when no manufacturers match search */}
                    {manufacturerSearch && !manufacturers.filter(m => 
                      m.toLowerCase().includes(manufacturerSearch.toLowerCase())).length && (
                      <div className="px-4 py-3 text-gray-500 body-sm italic text-center">
                        No manufacturers found matching "{manufacturerSearch}"
                      </div>
                    )}
                  </div>
                </div>
              )}
            </div>
            
            {/* Model Search Input - Now below manufacturer search */}
            <div className="flex flex-col mt-5">
              <label htmlFor="modelSearch" className="heading-sm text-gray-800 mb-2">Model</label>
              <input
                id="modelSearch"
                className="search-input body-md text-gray-900"
                type="text"
                placeholder="Search by model..."
                value={query}
                onChange={e => setQuery(e.target.value)}
                ref={searchRef}
                aria-label="Search for boiler manual"
              />
            </div>
          </div>
        </div>
        
        {/* Results section */}
        <div aria-live="polite" className="w-full">
          {error && <div className="p-5 bg-red-50 text-red-700 rounded-lg border border-red-100 mb-4 body-md">{error}</div>}
          
          {/* Render no results message if needed */}
          {!loading && manuals.length === 0 ? (
            <div className="p-4 flex flex-col items-center justify-center h-full min-h-[300px] text-center">
              <img src="/empty-state.svg" alt="No results" className="w-32 h-32 mb-4" />
              <h2 className="text-xl font-semibold text-gray-700 dark:text-gray-300 mb-2">No manuals found</h2>
              <p className="text-gray-600 dark:text-gray-400 mb-4">
                {selectedManufacturer ? `We couldn't find any manuals for ${selectedManufacturer} matching your search.` : 'Please select a manufacturer or search for a model to find manuals.'}
              </p>
              <button
                onClick={() => {
                  setSelectedManufacturer('');
                  setQuery('');
                }}
                className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors"
              >
                Clear filters
              </button>
            </div>
          ) : loading ? (
            /* Loading skeleton */
            <div className="w-full flex flex-col gap-4">
              {[1, 2, 3].map(i => (
                <div key={i} className="p-5 rounded-xl shadow-sm bg-white">
                  <div className="skeleton h-6 w-3/4 mb-3"></div>
                  <div className="skeleton h-4 w-1/3 mb-4"></div>
                  <div className="flex justify-between items-center">
                    <div className="skeleton h-4 w-1/4"></div>
                    <div className="skeleton h-10 w-24 rounded-lg"></div>
                  </div>
                </div>
              ))}
            </div>
          ) : manuals.length > 0 ? (
            <div className="w-full flex flex-col gap-4">
              {manuals.map(manual => (
                <div
                  key={manual.id}
                  className="result-card"
                >
                  <div className="flex-1 pr-4">
                    <h3 className="text-gray-900 font-medium text-lg truncate" title={manual.model}>{manual.model}</h3>
                    <p className="body-sm text-gray-600">{manual.make}</p>
                  </div>
                  <button
                    className="download-btn"
                    onClick={() => handleDownload(manual.id)}
                    disabled={downloading || downloadingId === manual.id}
                  >
                    {downloadingId === manual.id ? 'Downloading...' : (
                      <>
                        <span>Download PDF</span>
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                          <polyline points="7 10 12 15 17 10"></polyline>
                          <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                      </>
                    )}
                  </button>
                </div>
              ))}
            </div>
          ) : query || selectedManufacturer ? (
            <div className="w-full p-8 bg-gray-50 flex flex-col items-center justify-center rounded-lg text-center border border-gray-200">
              <div className="text-gray-400 mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
                  <path d="M12 11v5"></path>
                  <path d="M12 18v.01"></path>
                </svg>
              </div>
              <p className="heading-sm text-gray-600 mb-2">No manuals found</p>
              <p className="body-md text-gray-500">No manuals match '{query}'{selectedManufacturer ? ` for ${selectedManufacturer}` : ''}. Try a different keyword.</p>
            </div>
          ) : (
            <div className="w-full p-8 bg-gray-50 flex flex-col items-center justify-center rounded-lg text-center border border-gray-200">
              <div className="text-gray-400 mb-4">
                <span className="text-4xl">ðŸ§ </span>
              </div>
              <p className="heading-sm text-gray-600 mb-2">Start your search</p>
              <p className="body-md text-gray-500">Start typing a model name or number, or select a manufacturer</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
