import express from 'express';
import cors from 'cors';
import aiAuth from './authMiddleware.js';
import dotenv from 'dotenv';
import { fileURLToPath } from 'url';
import path from 'path';
import { createClient } from '@supabase/supabase-js';
import fetch from 'node-fetch';
import boilerApi from './boilerApi.js';
import boilerKnowledge from './boilerKnowledgeService.js';

// Get directory name for the current module
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load .env file from the server directory
dotenv.config({ path: path.resolve(__dirname, '.env') });

// Initialize Supabase client
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_ANON_KEY
);

const app = express();
const PORT = process.env.PORT || 3005;

app.use(cors());
app.use(express.json());

// Register boiler API routes
app.use('/api/boiler', boilerApi);

// --- ADMIN AUTH MIDDLEWARE ---
const adminAuth = async (req, res, next) => {
  // TODO: Implement real admin check using Supabase Auth roles
  // For now, allow all requests to pass for demonstration
  next();
};

// --- GET /api/manuals ---
app.get('/api/manuals', async (req, res) => {
  try {
    const search = req.query.search || '';
    const manufacturer = req.query.manufacturer || '';
    const sortBy = req.query.sort || 'make';
    const order = req.query.order === 'asc' ? 'asc' : 'desc';

    // Query Supabase 'boilers' table
    let query = supabase.from('boilers').select('*');
    if (search) {
      query = query.ilike('model', `%${search}%`);
    }
    if (manufacturer) {
      query = query.eq('make', manufacturer);
    }
    query = query.order(sortBy, { ascending: order === 'asc' });

    const { data: manuals, error } = await query;
    if (error) throw error;

    // Format the response
    const formattedManuals = (manuals || []).map(manual => ({
      id: manual.id,
      make: manual.make,
      model: manual.model,
      pdf_url: manual.pdf_url,
      created_at: manual.created_at,
      gc_number: manual.gc_number
    }));
    res.json({ manuals: formattedManuals });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// --- GET /api/manuals/:id ---
app.get('/api/manuals/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { data: manual, error } = await supabase.from('boilers').select('*').eq('id', id).single();
    if (error) throw error;
    if (!manual) return res.status(404).json({ error: 'Manual not found' });
    res.json({ manual });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// --- GET /api/manuals/:id/download ---
app.get('/api/manuals/:id/download', async (req, res) => {
  try {
    const { id } = req.params;
    const { data: manual, error } = await supabase.from('boilers').select('*').eq('id', id).single();
    if (error) throw error;
    if (!manual || !manual.pdf_url) return res.status(404).json({ error: 'Manual or PDF not found' });
    res.json({ download_url: manual.pdf_url, filename: manual.model + '.pdf' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// --- GET /api/manufacturers ---
app.get('/api/manufacturers', async (req, res) => {
  try {
    const { data, error } = await supabase.from('boilers').select('make').neq('make', null);
    if (error) throw error;
    // Unique and sorted
    const manufacturers = [...new Set((data || []).map(m => m.make))].sort();
    res.json({ manufacturers });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// --- POST /api/manuals (admin only, stub) ---
app.post('/api/manuals', adminAuth, async (req, res) => {
  res.status(501).json({ error: 'Manual creation via API not implemented. Use Supabase dashboard.' });
});

// --- POST /api/manuals/upload (admin only, stub) ---
app.post('/api/manuals/upload', adminAuth, async (req, res) => {
  res.status(501).json({ error: 'File upload via API not implemented. Use Supabase dashboard or implement file upload.' });
});

// --- User & Admin profile endpoints (stubbed) ---
app.get('/api/user', (req, res) => {
  res.status(501).json({ error: 'User profile API not implemented. Use Supabase Auth.' });
});

app.post('/api/chat', async (req, res) => {
  const { history } = req.body;
  if (!Array.isArray(history) || history.length === 0) {
    return res.status(400).json({ error: 'Missing or invalid chat history' });
  }
  
  // Add debugging for history tracking
  console.log(`Processing chat request with ${history.length} messages`);
  
  // Analyze the last user message to extract boiler information
  const lastUserMessage = history.filter(msg => msg.sender === 'user').pop();
  let relevantKnowledge = '';
  let contextExtracted = false;
  
  if (lastUserMessage) {
    // Extract context from user message for better responses
    const userText = lastUserMessage.text.toLowerCase();
    
    // Check for safety concerns first
    if (userText.includes('gas smell') || userText.includes('smell gas')) {
      const gasSafety = boilerKnowledge.getSafetyWarning('Gas smell');
      if (gasSafety) {
        relevantKnowledge += '\n\nURGENT SAFETY INFORMATION - GAS LEAK:\n' + 
          gasSafety.instructions.map((i, idx) => `${idx+1}. ${i}`).join('\n');
        contextExtracted = true;
      }
    }
    
    if (userText.includes('carbon monoxide') || userText.includes('co alarm') || 
        userText.includes('headache') || userText.includes('dizzy') || 
        userText.includes('alarm beeping')) {
      const coSafety = boilerKnowledge.getSafetyWarning('Carbon monoxide concerns');
      if (coSafety) {
        relevantKnowledge += '\n\nURGENT SAFETY INFORMATION - CARBON MONOXIDE:\n' + 
          coSafety.instructions.map((i, idx) => `${idx+1}. ${i}`).join('\n') + 
          '\n\nPossible symptoms: ' + coSafety.symptoms.join(', ');
        contextExtracted = true;
      }
    }
    
    // Extract manufacturer and fault code
    const manufacturerMatch = userText.match(/\b(worcester|vaillant|baxi|ideal|glow ?worm|potterton|viessmann|ariston|navien)\b/i);
    const faultCodeMatch = userText.match(/\b([a-z][0-9]{1,2}|[a-z]\.[0-9]{1,2}|[ef][0-9]{1,3})\b/i) || 
                           userText.match(/fault(\s+code)?\s+([a-z0-9]{1,4})/i) || 
                           userText.match(/error(\s+code)?\s+([a-z0-9]{1,4})/i);
    
    let manufacturer = manufacturerMatch ? manufacturerMatch[0] : null;
    let faultCode = faultCodeMatch ? (faultCodeMatch[2] || faultCodeMatch[1]) : null;
    
    // If we have both manufacturer and fault code, look up information
    if (manufacturer && faultCode) {
      const faultInfo = boilerKnowledge.findFaultCode(manufacturer, faultCode);
      if (faultInfo) {
        relevantKnowledge += `\n\nRELEVANT FAULT CODE INFORMATION:\nManufacturer: ${faultInfo.manufacturer}\nCode: ${faultInfo.code}\nDescription: ${faultInfo.description}\nCommon causes: ${faultInfo.causes.join(', ')}\nTroubleshooting steps:\n`;
        faultInfo.troubleshooting.forEach((step, idx) => {
          relevantKnowledge += `${idx+1}. ${step}\n`;
        });
        contextExtracted = true;
      }
    }
    
    // Check for common symptoms
    const symptomPatterns = {
      'No heating': /\b(no heat|not heating|won'?t heat|cold house|rads cold)\b/i,
      'No hot water': /\b(no hot water|cold water|no water heat|shower cold)\b/i,
      'Boiler noise': /\b(noise|loud|bang|knocking|gurgling|kettling|whistle)\b/i,
      'Leaking boiler': /\b(leak|drip|water com(es|ing) out|puddle)\b/i,
      'Low pressure': /\b(low pressure|pressure (too )?low|dropping pressure|pressure drop)\b/i,
      'Radiator cold spots': /\b(cold spot|radiator cold|half hot|bottom cold)\b/i
    };
    
    for (const [symptom, pattern] of Object.entries(symptomPatterns)) {
      if (pattern.test(userText)) {
        const symptomInfo = boilerKnowledge.getSymptomHelp(symptom);
        if (symptomInfo) {
          relevantKnowledge += `\n\nRELEVANT INFORMATION FOR "${symptom}":\n`;
          symptomInfo.forEach((cause) => {
            relevantKnowledge += `Possible cause: ${cause.cause} (Probability: ${cause.probability})\nChecks to perform:\n`;
            cause.checks.forEach((check, idx) => {
              relevantKnowledge += `${idx+1}. ${check}\n`;
            });
          });
          contextExtracted = true;
          break; // Only use the first matching symptom to avoid information overload
        }
      }
    }
  }
  
  // If no context was extracted, add a general note
  if (!contextExtracted) {
    relevantKnowledge = '\n\nNo specific boiler fault or symptom detected in the query. Provide general heating engineer advice based on your experience.';
  }
  
  // Use DEEPSEEK_API_KEY_1 as primary, the rest as fallbacks
  const keys = [
    process.env.DEEPSEEK_API_KEY_1,
    process.env.DEEPSEEK_API_KEY_2,
    process.env.DEEPSEEK_API_KEY_3,
    process.env.DEEPSEEK_API_KEY_4,
    process.env.DEEPSEEK_API_KEY_5,
    process.env.DEEPSEEK_API_KEY_6
  ].filter(Boolean);
  const systemPrompt = {
    role: 'system',
    content: `You are BoilerBrain, an expert-level diagnostic assistant for professional gas engineers.
Pull directly from Supabase tables: boiler_fault_codes, boiler_diagnostics, gas_safety_regulations, building_regulations, and regulation_visuals.
Be clear, efficient, and directâ€”never patronise. Your role is to help engineers solve real faults quickly and compliantly.
Where relevant, provide images, step-by-step diagnostics, and regulation summaries without quoting law.
Always assume the user is competent. Never suggest referring to an installer. You're the engineer's second set of eyes on-site.

IMPORTANT MEMORY INSTRUCTIONS:
1. Pay careful attention to the CURRENT boiler manufacturer and model mentioned by the user
2. The user may change the boiler make or model during the conversation - always update your understanding
3. If the user says they have a different boiler than previously mentioned, acknowledge the change
4. Always get both the manufacturer AND model before providing specific troubleshooting advice
5. Maintain context of the entire conversation and refer back to earlier information when relevant`
  };
  // Add extracted knowledge to the system prompt
  const enhancedSystemPrompt = {
    role: 'system',
    content: systemPrompt.content + relevantKnowledge
  };
  
  // Create a context summary of important info from earlier messages if history is long
  let contextSummary = '';
  if (history.length > 10) {
    const earlierMessages = history.slice(0, -10);
    
    // Extract manufacturer and model information from earlier messages
    const userMessages = earlierMessages.filter(msg => msg.sender === 'user');
    const combinedUserText = userMessages.map(msg => msg.text).join(' ');
    
    // Look for manufacturer and model mentions
    const manufacturerMatches = combinedUserText.match(/\b(worcester|bosch|vaillant|baxi|ideal|glow\s*worm|potterton|ariston|viessmann|alpha|ferroli)\b/gi);
    const modelMatches = combinedUserText.match(/\b([a-z][0-9]{1,3}|[a-z0-9]+-[a-z0-9]+|ecomax|ecotec|logic|vogue|combi|i\d+)\b/gi);
    
    if (manufacturerMatches || modelMatches) {
      contextSummary = "CONVERSATION CONTEXT: ";
      if (manufacturerMatches) {
        contextSummary += `Previously mentioned boiler manufacturer(s): ${[...new Set(manufacturerMatches)].join(', ')}. `;
      }
      if (modelMatches) {
        contextSummary += `Previously mentioned model(s): ${[...new Set(modelMatches)].join(', ')}. `;
      }
    }
  }
  
  // Append the context summary as a system message if we have one
  const messages = [
    enhancedSystemPrompt,
    ...(contextSummary ? [{ role: 'system', content: contextSummary }] : []),
    ...history.slice(-10).map(msg => ({
      role: msg.sender === 'user' ? 'user' : 'assistant',
      content: msg.text
    }))
  ];
  
  console.log('[Chat] Enhanced prompt with knowledge:', relevantKnowledge ? 'Yes' : 'No');
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    try {
      console.log(`[DeepSeek Proxy] Trying API key #${i+1}`);
      const dsRes = await fetch('https://api.deepseek.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${key}`
        },
        body: JSON.stringify({
          model: 'deepseek-chat',
          messages,
          max_tokens: 200
        })
      });
      console.log(`[DeepSeek Proxy] Response status: ${dsRes.status}`);
      if (dsRes.ok) {
        const data = await dsRes.json();
        if (data.choices?.[0]?.message?.content) {
          return res.json({ response: data.choices[0].message.content });
        }
      } else {
        let errText;
        try {
          errText = await dsRes.text();
          console.warn(`[DeepSeek Proxy] Error response:`, errText);
        } catch (e) {
          console.warn(`[DeepSeek Proxy] Error: Could not read error body`);
        }
      }
    } catch (err) {
      console.error(`[DeepSeek Proxy] Network/JS error:`, err);
      continue;
    }
  }
  // All keys failed
  res.json({ response: "I'm having trouble connecting to the AI right now. Please try again later!" });
});

// Start server
app.listen(PORT, () => {
  console.log(`Boiler Brain server running on http://localhost:${PORT}`);
});
